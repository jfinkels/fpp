%% fpp.tex - fixed-parameter parallelizability
%%
%% Copyright 2016 Jeffrey Finkelstein.
%%
%% This LaTeX markup document is made available under the terms of the Creative
%% Commons Attribution-ShareAlike 4.0 International License,
%% https://creativecommons.org/licenses/by-sa/4.0/.
\documentclass{article}

\usepackage{amsmath}
\usepackage{amssymb}
%% This must come before hyperref.
\usepackage{amsthm}
%% This is strongly recommended by biblatex.
\usepackage[english]{babel}
\usepackage[backend=biber]{biblatex}
\usepackage[T1]{fontenc}
%% This must come before csquotes.
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
%% This is strongly recommended by biblatex.
\usepackage{csquotes}
%% This must come before hyperref.
\usepackage{thmtools}
%% This must come before complexity.
\usepackage{hyperref}
\usepackage{complexity}
\usepackage[firstpage]{draftwatermark}
\usepackage[final]{microtype}
\usepackage{textcomp}

%% Set the amount by which certain characters protrude into the margins.
%%
%% \LoadMicrotypeFile{cmr}
%%
%%     This command forces the built-in protrusion settings for the Computer
%%     Modern Roman (cmr) font family to become available at this point, so
%%     that we can override these settings on the next line. Even though we are
%%     really using the Latin Modern Roman (lmr) fonts, microtype uses the cmr
%%     configuration file.
%%
%% \SetProtrusion
%%
%%     This instructs the microtype package that we are going to modify the
%%     protrusion settings.
%%
%% [load=lmr-T1]
%%
%%     Loads the Type 1 (T1) encoding of the lmr font family, thereby setting
%%     the default protrusion values for all the characters. This is only
%%     possible after the \LoadMicrotypeFile{cmr} command (microtype
%%     essentially considers lmr to be an alias for cmr).
%%
%% {encoding=T1, family=lmr}
%%
%%     Indicates that we are going to modify the protrusion values for the T1
%%     encoding of the lmr font family.
%%
%% \textquotedblright = {,1000} (and similar commands)
%%
%%     Force the character given by \textquotedblright to have default
%%     protrusion on the left margin (given by an empty string before the
%%     comma) and full protrusion (that is, protrusion value 1000) on the right
%%     margin.
\LoadMicrotypeFile{cmr}
\SetProtrusion
    [load=lmr-T1]
    {encoding=T1, family=lmr}
    {
      \textquotedblright = {,1000},
      \textquotedblleft = {1000,},
      {'} = {,1000},
      {,} = {,1000},
      {:} = {,1000},
      {;} = {,1000},
      {.} = {,1000}
    }

%% Set the ``work-in-progress'' watermark for the first page.
\SetWatermarkLightness{0.9}
\SetWatermarkText{Work-in-progress}
\SetWatermarkFontSize{3.5cm}

%% Set the title and author of the PDF file.
\hypersetup{pdftitle={Fixed-parameter parallelizability}, pdfauthor={Jeffrey Finkelstein}}

%% Declare the bibliography file.
\addbibresource{fpp.bib}

%% Declare theorem- and proof-like environments.
\declaretheorem[numberwithin=section]{theorem}
\declaretheorem[numberlike=theorem]{lemma}
\declaretheorem[numberlike=theorem]{conjecture}
\declaretheorem[numberlike=theorem]{corollary}
\declaretheorem[numberlike=theorem]{proposition}
\declaretheorem[numberlike=theorem]{assumption}
\declaretheorem[numberlike=theorem, style=definition]{definition}
\newenvironment{justification}{\begin{proof}[Justification]}{\end{proof}}

%% Custom commands are declared here.
\newcommand{\email}[1]{\textlangle\href{mailto:#1}{\nolinkurl{#1}}\textrangle}
\newcommand{\todo}[1]{\textbf{TODO #1}}

%%%% Commands for parameterized problem names.
\newcommand{\dash}{\textnormal{-}}
\newcommand{\pncsat}{p\dash\log\dash\NC^d\dash\textsc{Circuit Sat}}
\newcommand{\pgrouprank}{p\dash\textsc{Group Rank}}
\newcommand{\pMC}{p\dash\MC}
\newcommand{\pWD}{p\dash\WD}
\newcommand{\pBHP}{p \dash \textsc{BHP}}
\newcommand{\pSCE}{p \dash \textsc{SCE}}
\newcommand{\pHDS}{p \dash \textsc{HDS}}
\newcommand{\pCkSAT}{p \dash k \dash \textsc{CSat}}
\newcommand{\pCkE}{p \dash k \dash \textsc{CE}}
\newcommand{\pWCE}{p \dash \textsc{WCE}}
\newcommand{\pPiFSAT}{p \dash \Pi_t \textsc{FSat}}
\newcommand{\pFSAT}{p \dash \textsc{FSat}}
\newcommand{\pCSAT}{p \dash \textsc{CSat}}
\newcommand{\pNCSAT}{p \dash k \dash \NC^d \textsc{CSat}}
\newcommand{\PiFSAT}{\Pi_t \textsc{FSat}}
\newcommand{\PiCSAT}{\Pi_t \textsc{CSat}}

%%%% Custom math commands.
\newcommand{\ceil}[1]{\lceil{#1}\rceil}
\newcommand{\gen}[1]{\langle#1\rangle}
\newcommand{\cl}[1]{\left[{#1}\right]}
\DeclareMathOperator{\depth}{depth}
\DeclareMathOperator{\nondet}{nondet}
\DeclareMathOperator{\size}{size}
\DeclareMathOperator{\Var}{Var}

%% Redefine the footnote environment so it has no reference and no number.
\long\def\symbolfootnote#1{\begingroup%
\def\thefootnote{\fnsymbol{footnote}}\footnotetext{#1}\endgroup}

%% Define the author, title, and date for the document.
\author{Jeffrey~Finkelstein\\ Computer Science Department, Boston University}
\title{Fixed-parameter parallelizability}

\begin{document}

\maketitle

\symbolfootnote{%
  Copyright 2016 Jeffrey~Finkelstein \email{jeffreyf@bu.edu}.

  This document is licensed under the Creative Commons Attribution-ShareAlike 4.0 International License, which is available at \mbox{\url{https://creativecommons.org/licenses/by-sa/4.0/}}.
  The \LaTeX{} markup that generated this document can be downloaded from its website at \mbox{\url{https://github.com/jfinkels/fpp}}.
  The markup is distributed under the same license.
}

\tableofcontents

\section{Introduction}

%% Document content goes here.
%
% Global components at each level must follow this structure.
%
% % Foreword %
%
% %% Context (anyone - why now?) %%
%
% What is the current situation, and why is the need so important?
%
%
% %% Need (readers - why you?) %%
%
% Why is this relevant to the reader, and why does something need to be done?
% (Also reference relevant existing work.)
%
%
% %% Task (author - why me?) %%
%
% What was undertaken to address the need?
%
%
% %% Object (document - why this document?) %%
%
% What does this document cover?
%
%
% % Summary %
%
% %% Findings (author - what?)
%
% What did the work reveal when performing the task?
We show the existence of a $\P$-complete problem in $\para \NC$ (the circuit evaluation problem parameterized by depth \autoref{thm:cvpdepth}) and a $\P$-complete problem not in $\para \P$, unless $\NC = \P$ (the ``small'' circuit evaluation problem \autoref{thm:psce}).
We prove that $\para \NC = \para \WNC$ almost exactly when $\NC = \NNC[i(n) \log n]$ \autoref{sec:fppwpp}.
%
%
% %% Conclusion (readers - so what?)
%
% What did the findings mean for the audience?
%
%
% %% Perspective (anyone - what now?)
%
% What should be done next?

\section{Definitions}

\begin{definition}
  A \emph{Boolean circuit}, or simply a \emph{circuit}, $C$, is an directed acyclic graph.
  The \emph{size of a circuit}, denoted $\size(C)$, is the number of vertices in the underlying graph.
  The \emph{depth of a circuit}, denoted $\depth(C)$, is the length of a longest path from the root to a sink.
\end{definition}

\begin{definition}
  A function $f$ is \emph{circuit-computable} if there is a nonuniform family of Boolean circuits $\{C_n\}_{n \in \mathbb{N}}$ such that for each $x$ we have $f(x) = C_n(x)$, where $n = |x|$.

  A language is \emph{circuit-decidable} if it has a circuit-computable characteristic function.
  We may also require that the size and depth of each circuit $C_n$ in the family be circuit-computable from just $n$, the length of the input.
  In this case, we say the language is \emph{circuit-decidable with uniform size and depth}.
\end{definition}

Nonuniformity is required in \autoref{thm:eventually} and \autoref{thm:rmparam}, among other theorems, in which the size of the input relative to the size of the parameter for an instance of the parameterized problem selects which of two circuits to use.
If the circuits were uniform, we would need to include both alternatives as subcircuits of a single larger circuit, thereby making the circuits too deep to meet the required circuit depth bounds.
\todo{
  Early on, I tried to see what would happen if we place the parameterized running time in the uniformity part of the computation (i.e. $\para \L$-uniform $\NC$ circuits instead of $\L$-uniform $\para \NC$ circuits), but I could not show anything.
  However, I would like to take another look at this.
}

\begin{definition}[Decision problems and parameterized problems]
  A \emph{language} is a set of binary strings.
  A \emph{parameterization} is a computable function $\kappa$ from binary strings to natural numbers.
  A \emph{parameterized problem} is a pair $(Q, \kappa)$, where $Q$ is a language and $\kappa$ is a parameterization.
\end{definition}

\begin{definition}[Slices of parameterized problems]
  For each positive integer $k$ and each parameterized problem $(Q, \kappa)$, the \emph{$k$th slice of $Q$}, denoted $(Q, \kappa)_k$, is defined by
  \[
  (Q, \kappa)_k = \{(x, k) \, | \, x \in Q \text{ and } \kappa(x) = k\}.
  \]
\end{definition}

\begin{definition}[$\NNC^d$ and $\NC^d$]
  Let $d$ be a natural number.
  A language $Q$ is in the class $\NNC^d[b(n)]$ if there is a nondeterministic circuit family $\{C_n\}$ such that for each string $x$ of length $n$,
  \begin{itemize}
  \item $x \in Q$ if and only if $C_n(x) = 1$,
  \item $\size(C_n) \leq n^{O(1)}$,
  \item $\depth(C_n) \leq O(\log^d n)$,
  \item $\nondet(C_n) \leq b(n)$.
  \end{itemize}
  If $b$ is the zero function, then the language is in the class $\NC^d$.
\end{definition}

Here, the notion of ``acceptance'' for a circuit is a nondeterministic one: $C_n(x) = 1$ if and only if there is a binary string $w$ of length $b(n)$ such that $C_n(x, w) = 1$.

Throughout we will often assume without loss of generality that functions like circuit size and depth bounds, nondeterministism bounds, and polynomials, are increasing

\section{Fixed-parameter parallelizability}
\label{sec:pcompletefpp}

The $\P$-complete problems are considered tractable but inherently sequential; adding more processors does not provide any significant reduction in the time required to find a solution, even thought they can be solved in polynomial time.
But can the lack of parallelizability for these problems depend on a parameterization of the problem, thereby isolating some of the ``sequential-ness'' of the problem in the value of the parameter?

\subsection{Definition of \texorpdfstring{$\para \NC$}{paraNC}}

\begin{definition}[$\para \NC^d$]
  Let $d$ be a natural number.
  A parameterized problem $(Q, \kappa)$ is in the class $\para \NC^d$ if there is a circuit-computable function $f$ and a nonuniform family $\{C_{n, k}\}$ of bounded fan-in Boolean circuits such that for each string $x$,
  \begin{itemize}
  \item $x \in Q$ if and only if $C_{n, k}(x) = 1$, where $n = |x|$ and $k = \kappa(x)$,
  \item $\size(C_{n, k}) \leq f(k) n^{O(1)}$,
  \item $\depth(C_{n, k}) \leq f(k) + O(\log^d n)$.
  \end{itemize}
  If instead the depth is bounded by $f(k) O(\log^d n)$, the class is denoted $\para \NC^{d \uparrow}$, a superclass of $\para \NC^d$.

  If the circuits are of unbounded fan-in, the classes are $\para \AC^d$ and $\para \AC^{d \uparrow}$, respectively.
\end{definition}

The classes $\para \AC^{d \uparrow}$ were first defined in \autocite{bst15}.

\subsection{Example problem in \texorpdfstring{$\para \NC$}{paraNC}}

The parameterized vertex cover problem is in $\para \AC^0$ \autocite{bst15}, but the underlying decision problem is $\NP$-complete.
We are interested in finding a problem in $\para \NC$ whose underlying decision problem is $\P$-complete.
One way to do this is to choose $Q$ to be a $\P$-complete problem and $\kappa$ to be the ``degenerate'' parameterization function $\kappa(x) = |x|$.

\begin{definition}[$p \dash s \dash \textsc{Circuit Evaluation}$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$ on $n$ inputs with size $m$ and depth $d$, binary string $x$ of length $n$. \\
    \textbf{Parameter:} & $m$. \\
    \textbf{Question:} & Does $C(x) = 1$?
  \end{tabular}
\end{definition}

\begin{theorem}
  $p \dash s \dash \textsc{Circuit Evaluation}$ is in $\para \NC$ and the underlying decision problem is $\P$-complete.
\end{theorem}
\begin{proof}
  The circuit evaluation problem is $\P$-complete by \autocite{ladner75}.
  Since the parameterization is monotonically increasing with the size of the input, the problem is in $\para \NC$ by the technique of \autocite[Proposition~1.7]{fg06}.
\end{proof}

To find a non-degenerate example, we can parameterize the circuit evaluation problem by depth instead of size.

\begin{definition}[$p \dash d \dash \textsc{Circuit Evaluation}$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$ on $n$ inputs with size $m$ and depth $d$, binary string $x$ of length $n$. \\
    \textbf{Parameter:} & $d$. \\
    \textbf{Question:} & Does $C(x) = 1$?
  \end{tabular}
\end{definition}

\begin{theorem}\label{thm:cvpdepth}
  $p \dash d \dash \textsc{Circuit Evaluation}$ is in $\para \AC^{0 \uparrow}$ and the underlying decision problem is $\P$-complete.
\end{theorem}
\begin{proof}
  As stated in the proof of the previous theorem, the circuit evaluation problem is $\P$-complete.
  Evaluating the circuit $C$ of size $m$ and depth $d$ on inputs $x$ can be performed by the depth-universal circuit $U$ of \autocite{ch85}.
  The size of $U$ is $O(m)$ and the depth is $d$, so there is a function $f$ such that the size is bounded by $f(d) m^{O(1)}$ and the depth by $f(d)$.
  Therefore the circuit evaluation problem parameterized by circuit depth is in $\para \AC^{0 \uparrow}$.
\end{proof}

For a problem with a standard parameterization derived from an optimization problem (see \autoref{def:standard} below), consider the ``depth of ones'' problem.
The circuit evaluation problem is a special case of the depth of ones problem if we choose $k$ to be the depth of the circuit $C$.

\begin{definition}[$p \dash \textsc{Ones Depth}$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$ on $n$ inputs with size $m$ and depth $d$, binary string $x$ of length $n$, positive integer $k$. \\
    \textbf{Parameter:} & $k$. \\
    \textbf{Question:} & When evaluating $C(x)$, do ones propagate to depth at least $k$?
  \end{tabular}
\end{definition}

As an optimization problem, the depth of ones problem is inapproximable up to any constant factor by any $\NC$ circuit, unless $\NC = \P$ \autocite{ks88}.
Contrast this with the complexity of the corresponding parameterized problem.

\begin{theorem}
  $p \dash \textsc{Ones Depth}$ is in $\para \AC^{0 \uparrow}$ and the underlying decision problem is $\P$-complete.
\end{theorem}
\begin{proof}
  Computing the depth of ones in a circuit is $\P$-complete \autocite{ks88} (see also \autocite[Problem~A.1.10]{ghr95}).
  The naïve algorithm for solving this problem is to take the subcircuit consisting of all gates starting from the inputs and extending through layer $k$, evaluating that (multi-output) circuit, then applying a single \textsc{or} gate to decide whether any of the gates at layer $k$ evaluated to one.
  For each gate at layer $k$, use an instance of the depth-universal circuit to evaluate the single-output circuit induced by that gate.
  This yields a circuit of depth $O(k)$ and size $f(k) m^{O(1)}$ for some $f$, where $m$ is the size of the circuit given as input.
  Therefore this problem is in $\para \AC^{0\uparrow}$.
\end{proof}

\subsection{Relationship between \texorpdfstring{$\para \NC$}{paraNC} and \texorpdfstring{$\NC$}{NC}}

The lemmas in this section allow us to transform, in certain circumstances, a highly parallel algorithm for a decision problem into a fixed-parameter parallelizable one for a parameterized problem, or vice versa.
They will be used in later sections to provide evidence against the collapse of larger complexity classes to $\para \NC$.

\begin{definition}\label{def:eventually}
  Suppose $d$ is a natural number and $(Q, \kappa)$ is a parameterized problem.
  We say the problem $(Q, \kappa)$ is \emph{eventually in $\NC^d$} if there is a circuit-computable function $h$ and an $\NC^d$ family of circuits $\{C_n\}_{n \in \mathbb{N}}$ such that for each $x$ of length $n$, if $n \geq h(\kappa(x))$, then $x \in Q$ if and only if $C_n(x) = 1$.
\end{definition}

This theorem is a characterization of parameterized problems in the class $\para \NC^d$ as problems for which the parameter suggests an input size threshold, below which it suffices to perform an exhaustive search to solve the problem and after which we require an efficient algorithm.
It is the adaptation of \autocite[Theorem~1.37]{fg06}.

\begin{theorem}\label{thm:eventually}
  Suppose $d$ is a natural number and $(Q, \kappa)$ is a parameterized problem.
  If $Q$ is circuit-decidable with uniform size and depth and $(Q, \kappa)$ is eventually in $\NC^d$, then $(Q, \kappa)$ is in $\para \NC^d$.
\end{theorem}
\begin{proof}
  Let $h$ be the function that defines the lower bound on the length after which $(Q, \kappa)$ is in $\NC^d$.
  The nonuniform family of circuits $\{A_{n, k}\}$ that decides $(Q, \kappa)$ is defined by
  \[
  A_{n, k} =
  \begin{cases}
    C^1_n & \text{if } n < h(k) \\
    C^2_n & otherwise,
  \end{cases}
  \]
  where $\{C^1_n\}$ is the family of circuits that decides $Q$ and $\{C^2_n\}$ is the family of $\NC^d$ circuits that eventually decides $(Q, \kappa)$.
  The correctness of $A_{n, k}$ follows from the correctness of $C^1_n$ and $C^2_n$.

  Let $S$ and $D$ be the circuit-computable functions that give the size and depth, respectively, of $C^1_n$ from $n$.
  If $n < h(k)$, then
  \begin{align*}
    \size(A_{n, k}) & = \size(C^1_n) = S(n) \leq S(h(k)), \\
    \depth(A_{n, k}) & = \depth(C^1_n) = D(n) \leq D(h(k)).
  \end{align*}
  If $n \geq h(k)$, then
  \begin{align*}
    \size(A_{n, k}) & = \size(C^2_n) = n^{O(1)}, \\
    \depth(A_{n, k}) & = \depth(C^2_n) = O(\log^d n).
  \end{align*}
  An upper bound for the size of $A_{n, k}$ in either case is $S(h(k)) n^{O(1)}$ and for the depth $D(h(k)) + O(\log^d n)$.
  Since $S$ and $D$ are computable, composing each with $h$ yields another computable function, so these size and depth bounds meet the requirements of the definition of $\para \NC^d$.
\end{proof}

\begin{definition}\label{def:spreduction}
  Suppose $d$ is a natural number, $(Q, \kappa)$ is a parameterized problem, and $Q'$ is a decision problem.
  There is a \emph{small parameter $\NC^d$ many-one reduction} from $(Q, \kappa)$ to $Q'$ if there is a nondecreasing, unbounded, circuit-computable function $h$ and an $\NC^d$ family of circuits $\{R_n\}_{n \in \mathbb{N}}$ such that for each string $x$ of length $n$ with $\kappa(x) \leq h(n)$, we have $x \in Q$ if and only if $R_n(x) \in Q'$.
\end{definition}

\begin{lemma}\label{lem:upperinverse}
  Suppose $i$ is an unbounded, nondecreasing, circuit-computable function.
  Then there is an unbounded, nondecreasing, circuit-computable function $f_i$ such that for each natural number $n$, we have $f_i(i(n)) \geq n$.
  (We call $f_i$ the ``upper inverse'' of $i$.)
  \todo{Make this look like the inverse lemma.}
\end{lemma}
\begin{proof}
  \todo{Fill me in}
\end{proof}

This lemma is analogous to \autoref{thm:eventually}.
It demonstrates that the closure of $\NC$ under small parameter reductions is $\para \NC$.

\begin{lemma}\label{lem:spreduction}
  Suppose $d$ is a natural number, $(Q, \kappa)$ is a parameterized problem, and $Q'$ is a decision problem.
  If $Q$ is circuit-decidable with uniform size and depth, $Q'$ is in $\NC^d$, and there is a small parameter $\NC^d$ many-one reduction from $(Q, \kappa)$ to $Q'$, then $Q$ is in $\para \NC^d$.
\end{lemma}
\begin{proof}
  Let $h$ be the function that defines the upper bound on the parameter, below which there is an $\NC^d$ many-one reduction from $Q$ to $Q'$.
  Let $\{R_n\}$ be the $\NC^d$ circuit family computing the reduction.
  The nonuniform family of circuits $\{A_{n, k}\}$ that decides $(Q, \kappa)$ is defined by
  \[
  A_{n, k} =
  \begin{cases}
    C_n^1 & \text{if } h(n) < k \\
    C_{n'}^2 \circ R_{n} & \text{otherwise},
  \end{cases}
  \]
  where $\{C_n^1\}$ is the family of circuits that decides $Q$ with uniform size and depth, $\{C_n^2\}$ is the family of $\NC^d$ circuits that decides $Q'$, and $n'$ is the number of output bits of $R_n$.
  The correctness of $A_{n, k}$ follows from the correctness of the subsequent circuits.

  If $h(n) \geq k$, then the size and depth of the circuit are polynomial and polylogarithmic in $n$, respectively, because the size and depth of $C_{n'}^2$ and $R_n$ are.
  For the case when $h(n) < k$, consider the upper inverse $i_h$ of $h$ guaranteed by \autoref{lem:upperinverse}.
  By construction, $n \leq i_h(h(n)) < i_h(k)$.
  Now
  \begin{align*}
    \size(A_{n, k}) & = \size(C_n^1) = S(n) \leq S(i_h(k)), \\
    \depth(A_{n, k}) & = \depth(C_n^1) = D(n) \leq D(i_h(k)),
  \end{align*}
  where $S$ and $D$ are the (circuit-computable, nondecreasing) size and depth bounds for the circuit family $\{C_n^1\}$.
  Thus in either case, there is a sufficiently large circuit-computable function $f$ such the size of $A_{n, k}$ is bounded above by $f(k) n^{O(1)}$ and the depth $f(k) + O(\log^d n)$.
\end{proof}

This lemma shows that a many-one reduction to a fixed-parameter parallelizable problem can sometimes induce a highly parallel algorithm, if the parameter functions are bounded for the reduced instance.

\begin{lemma}\label{lem:reducetonc}
  Suppose $d$ is a positive integer, $Q$ is a decision problem, and $(Q', \kappa')$ is a parameterized problem.
  Suppose there is an $\NC^d$ many-one reduction from $Q$ to $Q'$, given by the circuit family $\{R_n\}$, and $(Q', \kappa')$ is in $\para \NC^d$ by a circuit family $\{C_{m, k}\}$ of size $f(k) m^{O(1)}$ and depth $f(k) + O(\log^d m)$ on inputs of length $m$.
  If $f(\kappa'(R_n(x))) \leq \min(n^{O(1)}, O(\log^d n))$, then $Q$ is in $\NC^d$.
\end{lemma}
\begin{proof}
  The circuit family that decides $Q$ is $\{A_n\}$, defined by $A_n = C_{m, k} \circ R_n$, where $m$ is the size of the output of $R_n$ and $k = \kappa'(R_n(x))$.
  Since $\size(R_n) = n^{O(1)}$, we have $m = n^{O(1)}$ as well.
  For correctness,
  \[
  x \in Q \iff R_n(x) \in Q' \iff C_{m, k}(R_n(x)) = 1.
  \]
  For size and depth bounds,
  \begin{align*}
    \size(A_n) & = \size(C_{m, k}) + \size(R_n) \\
    & = f(k) m^{O(1)} + n^{O(1)} \\
    & = f(k) n^{O(1)} + n^{O(1)} \\
    & = n^{O(1)} n^{O(1)} + n^{O(1)} \\
    & = n^{O(1)},
  \end{align*}
  and
  \begin{align*}
    \depth(A_n) & = \depth(C_{m, k}) + \depth(R_n) \\
    & = f(k) + O(\log^d m) + O(\log^d m) \\
    & = f(k) + O(\log^d m) \\
    & = f(k) + O(\log^d n) \\
    & = O(\log^d n) + O(\log^d n) \\
    & = O(\log^d n). \qedhere
  \end{align*}
\end{proof}

\subsection{Approximable optimization problems}

Yet another way to do this is to find an optimization problem whose budget problem is $\P$-complete while admitting a highly parallel approximation scheme.

\begin{definition}
  An \emph{optimization problem} $O$ is a four-tuple $(I, S, m, t)$, where $I$ is the set of instances, $S$ is the set of pairs $(x, w)$ where $w$ is a solution for $x$, the function $m$ computes the \emph{measure} (or \emph{objective value}) for such a pair, and $t$ is either $\min$ or $\max$.
\end{definition}

\begin{definition}\label{def:standard}
  The \emph{standard parameterization} of a minimization problem $O$, denoted $p\dash{O}$, is $(Q, \kappa)$, where $Q = \{ (x, k) \, | \, m^*(x) \leq k \}$ and $\kappa(x, k) = k$.
  The inequality is reversed for a maximization problem.
\end{definition}

\begin{definition}
  Suppose $(I, S, m, t)$ is an optimization problem and $(x, y) \in S$.
  The \emph{performance ratio} of the solution $y$ (with respect to $x$), denoted $R(x, y)$, is defined by
  \[
  R(x, y) = \max \left(\frac{m(x, y)}{m^*(x)}, \frac{m^*(x)}{m(x, y)}\right)
  \]
\end{definition}

The performance ratio $R(x, y)$ is a number in the interval $[1, \infty)$.
The closer $R(x, y)$ is to 1, the better the solution $y$ is for $x$, and the closer $R(x, y)$ to $\infty$, the worse the solution.

\begin{definition}
  An \emph{approximation scheme} for an optimization problem is a function $A$ such that for all $x$ and all positive integers $k$ we have $(x, A(x, k)) \in S$ and $R(x, A(x, k)) \leq 1 + \frac{1}{k}$.
\end{definition}

An approximation scheme induces a family of functions, $\{A_k\}_{k \in \mathbb{N}}$, that form progressively better approximations for the optimization problem.

%% \begin{definition}
%%   An optimization problem $O$ has an \emph{$\NC$ approximation scheme} if there is an approximation scheme $A$ for $O$ such that for each $k$, we have $A_k \in \FNC$, where $A_k(x) = A(x, k)$ for each $x$.
%% \end{definition}

\begin{definition}
  Suppose $O$ is an optimization problem with $O = (I, S, m, t)$ with $I$ and $S$ in $\NC$ and $m$ in $\FNC$.
  An optimization problem $O$ is in $\NCAS$ if there is an approximation scheme $A$ for $O$ such that for each $k$, we have $A_k \in \FNC$, where $A_k(x) = A(x, k)$ for each $x$.
  The problem is in $\FNCAS$ if there is an approximation scheme $A$ for $O$ such that $A \in \FNC$ (i.e. on both inputs).
\end{definition}

This definition is adapted from \autocite[Definition~1.31]{fg06}

\begin{definition}
  An optimization problem $O$ is in $\ENCAS$ if there is a circuit family $\{A_{n, k}\}$ and circuit-computable functions $f$ and $g$ such that
  \begin{itemize}
  \item $\{A_{n, k}\}$ is an approximation scheme for $O$,
  \item $\size(A_{n, k}) \leq f(k) n^{O(1)}$,
  \item $\depth(A_{n, k}) \leq g(k) \log^{O(1)} n$.
  \end{itemize}
\end{definition}

\begin{proposition}\label{prop:encas}
  $\FNCAS \subseteq \ENCAS \subseteq \NCAS$.
\end{proposition}

This theorem is an adaptation of \autocite[Theorem~1.32]{fg06}.

\begin{theorem}\label{thm:encasfpp}
  Let $O$ be an optimization problem.
  If $O$ is in $\ENCAS$, then $p\dash{O}$ is in $\para \NC$.
\end{theorem}
\begin{proof}
  Assume without loss of generality that $O$ is a minimization problem; the proof is similar if it is a maximization problem.
  Let $\{m_n\}$ be the $\NC$ circuit family that computes the measure function.
  Let $\{A_{n, k}\}$ be the circuit family such that
  \begin{itemize}
  \item $R(x, A_{n, k}(x, k)) \leq 1 + \frac{1}{k}$ for each $x$ and $k$,
  \item $\size(A_{n, k}) \leq f(k) n^{O(1)}$,
  \item $\depth(A_{n, k}) \leq f(k) + O(\log^{O(1)} n)$,
  \end{itemize}
  for some circuit-computable function $f$.
  Define the circuit family $\{C_{n, k}\}$ as
  \[
  C_{n, k}(x, k) = 1 \iff m(x, A_{n, k + 1}(x, k + 1)) \leq k,
  \]
  so $C_{n, k}$ outputs 1 if and only if the approximate solution corresponding to parameter $k + 1$ measures less than $k + 1$.
  (The function $m$ is really a circuit as well, chosen from a family of circuits depending on the number of bits in its inputs.)

  The size of $C_{n, k}$ is $O(\size(m) + \size(A_{n, k + 1}))$ and the depth is $O(\depth(m) + \depth(A_{n, k + 1})$.
  For some sufficiently large circuit-computable function $f'$, the size and depth bounds are $f'(k + 1) n^{O(1)}$ and $f'(k + 1) + O(\log^{O(1)} n)$, respectively.
  It remains to show correctness of $C_{n, k}$.

  Let $x$ be a string, let $k$ be a natural number, and let $y = A_{n, k + 1}(x, k + 1)$.
  If $C_{n, k} = 1$, then $m(x, y) \leq k$, so $m^*(k) \leq k$ and therefore $(x, k) \in p \dash O$.
  For the converse, if $C_{n, k} = 0$, then $m(x, y) \geq k + 1$, so
  \[
  m^*(x) \geq \frac{m(x, y)}{1 + \frac{1}{k + 1}} \geq \frac{k + 1}{1 + \frac{1}{k + 1}} = \frac{(k + 1)^2}{k + 2} > k.
  \]
  Thus $(x, k) \notin p \dash O$.
  Therefore, we conclude that $p \dash O$ is in $\para \NC$.
\end{proof}

The converse does not hold: the minimum vertex cover problem is a counterexample because it is in $\para \NC$ \autocite[Theorem~4.5]{bst15}.
\todo{Show an example of an optimization problem whose budget problem is $\P$-complete and whose standard parameterization is in $\para \NC$ but for which no $\ENCAS$ exists.}

Our goal now reduces to finding an optimization problem in $\ENCAS$ whose budget problem is $\P$-complete.
%% There exist problems that are $\P$-complete and have randomized $\FNCAS$ algorithms, so under a derandomization assumption, we can show a problem that fits the requirement.

\begin{definition}[\textsc{Maximum Flow}]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & directed graph $G$, a natural number capacity $c_e$ for each edge $e$, source node $s$, and target node $t$. \\
    \textbf{Solution:} & flow $F$, defined as a real number $F_e$ for each edge $e$ such that $F_e \leq c_e$ and at each vertex the total in-flow is at least the total out-flow. \\
    \textbf{Measure:} & total in-flow at $t$. \\
    \textbf{Type:} & maximization.
  \end{tabular}
\end{definition}

%% edge flows can have weights exponential in n

\begin{theorem}
  If $\NC = \RNC$, then the budget problem for \textsc{Maximum Flow} is $\P$-complete and the standard parameterization is in $\para \NC$.
\end{theorem}
\begin{proof}
  The budget problem for \textsc{Maximum Flow} is $\P$-complete \autocite[Problem~A.4.4]{ghr95}.
  The \textsc{Maximum Flow} problem is in randomized $\FNCAS$ \autocite[Theorem~4.5.2]{dsst97}.
  If $\NC = \RNC$, then randomized $\FNCAS$ equals deterministic $\FNCAS$.
  Thus, the problem is in $\ENCAS$, by \autoref{prop:encas}.
  Finally, the standard parameterization is in $\para \NC$ by \autoref{thm:encasfpp}.
\end{proof}

\todo{Can the randomization part of the RNC algorithm for MaxFlow be absorbed in the fixed-parameter part of the algorithm?}

% The positive linear programming problem is only in NCAS, not FNCAS.

\section{Fixed-parameter tractability}

%% What we really care about is the parameterized parallel complexity of problems in $\para \NC$, and specifically those with underlying decision problems that are $\P$-complete.
%% The $\WP$ hierarchy does not capture this.
%% This is similar to the way $\NNC[\polylog]$ allows us to consider efficient highly parallel verification but does not capture polynomial-time decision.

\subsection{Definition of \texorpdfstring{$\para \P$}{paraP}}

\begin{definition}
  A parameterized problem $(Q, \kappa)$ is in $\para \P$ if there is a deterministic Turing machine $M$, a polynomial $p$, and a computable function $f$ such that $M$ decides $Q$ within $f(\kappa(x)) p(n)$ steps.
\end{definition}

\subsection{Example problem in \texorpdfstring{$\para \P$}{paraP}}

Consider the parameterized high degree subgraph problem.

\begin{definition}[$p \dash \textsc{High Degree Subgraph}$, aka $\pHDS$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & undirected graph $G$, positive integer $d$. \\
    \textbf{Parameter:} & $d$. \\
    \textbf{Question:} & Does $G$ have a vertex-induced subgraph of minimum degree at least $d$?
  \end{tabular}
\end{definition}

The underlying decision problem is in $\P$, so the parameterized problem is fixed-parameter tractable.

\begin{theorem}[{\autocite{am84}}]
  $\pHDS$ is in $\para \P$.
\end{theorem}

The first two slices of the problem are in $\NC$, whereas all other slices are $\P$-complete.

\begin{theorem}[{\autocite{am84}}]
  \mbox{}
  \begin{enumerate}
  \item Both $pHDS_1$ and $\pHDS_2$ are in $\NC$.
  \item For each positive integer $d$ greater than two, $\pHDS_d$ is $\P$-complete.
  \end{enumerate}
\end{theorem}

%% As a maximization problem, the problem is approximable to within a certain constant factor, but inapproximable beyond that factor (unless $\NC = \P$) \autocite{am84}.

\todo{The proof that the high degree subgraph problem is $\P$-complete does not translate to proving that the parameterized high degree subgraph problem is $\para \P$-complete; for that reduction to work, the parameterization would need to be on the size of the graph, not the degree $d$.}

\todo{A reduction to place this problem in $\para \EP$ does not seem possible, since it seems hard to encode the degree of a subgraph in that way?}

\subsection{Completeness in \texorpdfstring{$\para \P$}{paraP}}

We define $\P$-completeness so that problems that are $\P$-complete are unlikely to see a significant decrease in time complexity when parallelism is allowed, under the assumption that $\NC \neq \P$.
Let us define $\para \P$-completeness similarly, so that $\para \P$-complete problems are unlikely to see a significant decrease in ``parameterized'' time complexity when ``parameterized'' parallelism is allowed, under the assumption that $\para \NC \neq \para \P$.
We already know that each $\P$-complete problem induces a $\para \P$-complete problem with a trivial parameterization \autocite[Proposition~14]{fg03}, however we are interested in natural problems with non-trivial parameterizations.
This subsection proves the existence of nontrivial parameterized problems that are not in $\para \P$ (under the assumption $\para \NC \neq \para \P$) and whose underlying decision problems are $\P$-complete, complementing \autoref{sec:pcompletefpp}, which proves the existence of parameterized problems in $\para \NC$ whose underlying decision problems are $\P$-complete.
Furthermore, this fills a hole left by \autocite{est15}.

The assumption $\para \NC \neq \para \P$ is reasonable because it is equivalent to the inequality $\NC \neq \P$.

\begin{proposition}
  $\para \NC = \para \P$ if and only if $\NC = \P$.
\end{proposition}
\begin{proof}
  The proof is trivial if we use the definitions of the complexity class $\para \mathcal{C}$ as the class of all parameterized problems $(Q, \kappa)$ for which there is a language $L$ in the complexity class $\mathcal{C}$ such that $x \in Q$ if and only if $(x, 1^{f(\kappa(x))}) \in L$.
  See \autocite[Proposition~8]{fg03}, for example.
\end{proof}

\begin{definition}[$\para \P$-completeness]
  A parameterized problem $(Q, \kappa)$ is \emph{$\para \P$-hard} if for each parameterized problem $(R, \lambda)$, there is a $\para \NC$ many-one reduction from $(R, \lambda)$ to $(Q, \kappa)$.
  If furthermore $(Q, \kappa)$ is in $\para \P$, then it is \emph{$\para \P$-complete}.
\end{definition}

\begin{proposition}
  If a $\para \P$-complete problem is in $\para \NC$, then $\para \NC = \para \P$.
\end{proposition}
\begin{proof}
  Follows from the downward closure of $\para \NC$ under $\para \NC$ many-one reductions.
\end{proof}

The following problem is adapted from \textsc{Short Deterministic Turing Machine Computation} in \autocite{cesati06}.

\begin{definition}[$p \dash \textsc{Bounded Halting Problem}$, aka $\pBHP$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & deterministic Turing machine $M$, binary string $x$ of length $n$, positive integer $t$ in unary, positive integer $c$. \\
    \textbf{Parameter:} & $t / n^c$ \\
    \textbf{Question:} & Does $M$ accept $x$ within $t$ steps?
  \end{tabular}
\end{definition}

\begin{theorem}
  $\pBHP$ is $\para \P$-complete.
\end{theorem}
\begin{proof}
  The underlying decision problem is in $\P$ (by a standard simulation on the deterministic universal Turing machine), so the parameterized problem is in $\FPT$.
  To show $\para \P$-hardness, we use a generic reduction.
  Let $(Q, \kappa)$ be an arbitrary parameterized problem in $\para \P$ and let $M$ be the deterministic Turing machine that decides $Q$ in time $f_M(k) n^c$ for some (circuit-)computable function $f_M$ and some positive integer $c$.
  The reduction is $x \mapsto (M, x, 1^{f_M(k) n^c}, c)$.
  This is computable by a (nonuniform) circuit family of constant depth and size $f(k) n^{O(1)}$, where $f$ is a circuit-computable function.
  The parameter of the reduced instance is $f_M(k) n^c / n^c$, or simply $f_M(k)$, which satisfies the parameter bound required by the definition of $\para \NC$ many-one reduction.
  Therefore we conclude that $\pBHP$ is $\para \P$-complete.
\end{proof}

The following problem is a modification of the problem \textsc{BS-BD-CVP} from \autocite{cd98}.

\begin{definition}[$p\dash\textsc{Small Circuit Evaluation}$, aka $\pSCE$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$ on $n$ inputs, binary string $x$ of length $n$, positive integer $k$, positive integer $\alpha$, multi-output Boolean circuit $f$ with size and depth of $C$ at most $f(k) n^\alpha$. \\
    \textbf{Parameter:} & $k$ \\
    \textbf{Question:} & Does $C(x) = 1$?
  \end{tabular}
\end{definition}

This theorem is related to \autocite[Corollary~2]{cd98}, where the authors prove that the \textsc{BS-BD-CVP} problem is complete for the class $\PNC$ (a class that exists between $\para \NC$ and $\para \P$) under $\para \NC$ many-one reductions.
While their reduction is a generic reduction, ours is a reduction from the parameterized bounded halting problem.

\begin{theorem}\label{thm:psce}
  $\pSCE$ is $\para \P$-complete.
\end{theorem}
\begin{proof}
  Membership in $\para \P$ is straightforward to prove: use the natural algorithm for evaluating a circuit which can be performed in linear time with respect to the size of the circuit.
  We must also compute $f(k) n^\alpha$ and compare it with the size and depth of the circuit $C$.
  Both of these are polynomial-time algorithms with respect to the size of the input, and hence the problem is in $\para \P$.

%% %%%% Here we showed a generic reduction.
%%   Now we prove $\FPT$-hardness.
%%   Let $(Q, \kappa)$ be an arbitrary parameterized problem in $\FPT$, so there is a deterministic Turing machine $M$ that decides $Q$ in time $f(k) n^\alpha$ for some (circuit-)computable function $f$ and positive integer $\alpha$.
%%   Let $C_{M, n}$ be the Boolean circuit that correctly simulates the action of $M$ on inputs of size $n$ with size $O(f(k) n^\alpha)^2$ and depth $O(f(k) n^\alpha)$; such a circuit exists due to \autocite{???}.
%%   Define the circuit family $\{R_{n, k}\}$ as follows.
%%   \[
%%   R_{n, k}(x) = (C_{M, n}, x, 2\alpha, \alpha, f^2, f, k),
%%   \]
%%   where the natural number $n = |x|$, the positive integer $k = \kappa(x)$, and the function $f^2$ denotes the function $x \mapsto (f(x))^2$.
%%   Let us confirm that the reduced instance is well-formed.
%%   \begin{itemize}
%%   \item $C_{M, n}$ is a Boolean circuit on $n$ inputs.
%%   \item The size of $C_{M, n}$ is $f^2(k) n^{2 \alpha}$.
%%   \item The depth of $C_{M, n}$ is $f(k) n^\alpha$.
%%   \item Both $f^2$ and $f$ are circuit-computable since $f$ is circuit-computable.
%%   \end{itemize}
%%   (There are some constants in the size and depth bounds that we have ignored, but those can be incorporated into the circuit-computable function $f$.)
%%   The reduction is correct because
%%   \[
%%   x \in Q \iff M \text{ accepts } x \iff C_{M, n}(x) = 1.
%%   \]

%%   Next, we show that $R_{n, k}$ has the appropriate size and depth bounds to be a valid $\FPP$ many-one reduction.
%%   The only computation that needs to be done by the circuit is to compute $2 \alpha$ from $\alpha$ and to compute the circuit for $f^2$ from the circuit for $f$.
%%   However, since both $\alpha$ and $f$ are entirely independent of $n$, the size and depth are constants with respect to $|x|$.
%%   The remaining elements of the tuple (namely $C_{M, n}$, $\alpha$, $f$, and $k$) are hardcoded directly in the circuit $R_{n, k}$ and are output directly with no further computation.
%%   The input $x$ is output directly as well.
%%   The overall size of the circuit is therefore of the form $s(k) n^{O(1)}$, and the depth of the form $d(k) n^{O(1)}$.

%%   Finally, for the parameter bound, the parameter of $R_{n, k}(x)$ is $k$, which is exactly $\kappa(x)$.
%%   Therefore we have shown that the circuit family $\{R_{n, k}\}$ is a correct $\FPP$ many-one reduction from an arbitrary parameterized problem $(Q, \kappa)$ to $\pSCE$.
%% \end{proof}

%% \begin{theorem}
%%   $\pBHP \equiv_m^{\FPP} p \dash \textsc{Short Circuit Evaluation}$.
%% \end{theorem}
%% \begin{proof}
  Now we prove $\para \P$-hardness.
  The reduction from $\pBHP$ is
  \[
  (M, x, 1^t, c) \mapsto (C_M, x, k, \alpha, f),
  \]
  where
  \begin{itemize}
  \item $C_M$ is the standard circuit of size $O(t^2)$ and depth $O(t)$ simulating $t$ steps of the action of $M$ on inputs of length $n$,
  \item $x$ is copied directly from the input,
  \item $k = t / n^c$.
  \item $\alpha = 2c$,
  \item $f$ is the function $x \mapsto x^2$,
  \end{itemize}
  This reduction is computable in the appropriate size and depth bounds, and its correctness follows from the correctness of the standard deterministic Turing machine-to-circuit reduction.
  To check that the reduced instance is well-formed, let us verify that the circuit $C_M$ meets the size and depth requirements.
  The size of $C_M$ is $O(t^2)$, which is $O(((t / n^c) n^c)^2)$, or simply $f(k) n^\alpha$.
  Similarly the depth of $C_M$ is $O(t)$, which is smaller than $O(t^2)$, and thus bounded above by $f(k) n^\alpha$ as well.
  (There are some constants in the size and depth bounds that we have ignored, but those can be incorporated into the definition of $f$.)
  Finally, the parameter in the original instance, $t / n^c$, is exactly the parameter of the reduced instance, so this reduction meets the necessary paramater bound.
  Therefore we have shown a correct $\para \NC$ many-one reduction from a $\para \P$-complete problem.
\end{proof}

As expected, if any of these $\para \P$-complete problems are fixed-parameter parallelizable, then $\para \NC = \para \P$.

It seems that most $\P$-complete problems will end up being $\para \P$-complete under this notion of completeness.
This doesn't really help us distinguish between different $\P$-complete problems based on how fixed-parameter parallelizable they are.
In the next subsection, we try a different approach.

\subsection{Parameterized complexity of efficient verification}

Consider the parameterized weighted circuit satisfiability and circuit evaluation problems.
A circuit is \emph{$k$-satisfiable} if there is a satisfying assignment of Hamming weight exactly $k$.

\begin{definition}[$p \dash \textsc{Circuit } k \dash \textsc{Satisfiability}$, aka $\pCkSAT$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$, natural number $k$. \\
    \textbf{Parameter:} & $k$. \\
    \textbf{Question:} & Is $C$ $k$-satisfiable?
  \end{tabular}
\end{definition}

The corresponding parameterized weighted circuit evaluation problem would then be as follows.
Let $\|x\|_1$ denote the Hamming weight (that is, the number of ones) in $x$.

\begin{definition}[$p \dash \textsc{Circuit } k \dash \textsc{Evaluation}$, aka $\pCkE$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$, binary string $x$, natural number $k$. \\
    \textbf{Parameter:} & $k$. \\
    \textbf{Question:} & Does $\|x\|_1 = k$ and $C(x) = 1$?
  \end{tabular}
\end{definition}

This is a little silly, since the Hamming weight of $x$ can be computed easily (in $\NC^1$ but not in $\AC^0$), but it is technically the ``verification'' problem corresponding to the satisfiability problem above.
Instead, we use a problem that is a little less silly while still equivalent under $\para \NC^1$ many-one reductions.
%% \todo{Reference for circuit computing Hamming weight; see \url{http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4781532}}

\begin{definition}[$p \dash \textsc{Weighted Circuit Evaluation}$, aka $\pWCE$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$, binary string $x$. \\
    \textbf{Parameter:} & $\|x\|_1$. \\
    \textbf{Question:} & Does $C(x) = 1$?
  \end{tabular}
\end{definition}

%% \begin{proposition}
%%   $\pCkE \equiv_m^{\para \NC^1} \pWCE$.
%% \end{proposition}
%% \begin{proof}
%%   Let $\kappa_1$ denote the parameterization of the problem on the left and $\kappa_2$ the parameterization of the problem on the right.
%%   The right-to-left reduction is simply $(C, x) \mapsto (C, x, \|x\|_1)$.
%%   The correctness as well as the size, depth, and parameterization bounds are straightforward to prove.

%%   The circuit family computing the left-to-right reduction is $\{R_{m, k}\}$, defined by
%%   \[
%%   R_{m, k}(C, x, k) =
%%   \begin{cases}
%%     (C, x) & \text{if } \|x\|_1 = k \\
%%     (\textsc{not}, 1) & \text{otherwise},
%%   \end{cases}
%%   \]
%%   where $m$ denotes the overall size of the input and \textsc{not} is the circuit which is a single negation gate.

%%   In order to prove correctness, first suppose $C(x) = 1$ and $\|x\|_1 = k$.
%%   By construction, $R(C, x, k) = (C, x)$, and $C(x) = 1$, as required.
%%   For the converse, there are two cases to consider.
%%   First, if $C(x) \neq 0$, then the output of $R(C, x, k)$ will be a circuit that outputs zero regardless of the value of $\|x\|_1$.
%%   Second, if $\|x\|_1 \neq k$, then the output of $R(C, x, k)$ will be $(\textsc{not}, 1)$, which is a circuit that outputs zero.
%%   In either case, $R(C, x, k)$ is not in $\pwce$, as required.
%%   Thus the reduction is correct.

%%   The size and depth bounds are trivial since the circuit $R_{m, k}$ essentially just copies its input to its output.
%%   Finally, for the bound on the parameterization in the reduced instance, there are two cases.
%%   If $\|x\|_1 = k$, then
%%   \[
%%   $\kappa_2(R(C, x, k)) = \kappa_2(C, x) = \|x\|_1 = k = \kappa_1(C, x).
%%   \]
%%   Otherwise,
%%   \[
%%   \kappa_2(R(C, x, k)) = \kappa_2(\textsc{not}, 1) = 1 \leq \kappa_1(C, x).
%%   \]
%%   In either case, the parameterization of the reduced instance is bounded above by the parameterization of the original instance.
%%   Therefore we have shown the left-to-right $\FPP$ reduction.
%% \end{proof}

In the setting of decision problems, we know that $\NP$ can be characterized as the closure of the circuit satisfiability problem under polynomial-time many-one reductions,
\[
\NP = \cl{\textsc{Circuit Satisfiability}}^{\leq_m^\P},
\]
and $\P$ as the closure of the circuit evaluation problem under $\NC^1$ many-one reductions,
\[
\P = \cl{\textsc{Circuit Evaluation}}^{\leq_m^{\NC^1}}.
\]
In the setting of parameterized problems, the class $\para \WP$ can be characterized as the closure of the parameterized weighted circuit satisfiability problem under fixed-parameter tractable many-one reductions,
\[
\para \WP = \cl{\pCkSAT}^{\leq_m^{\para \P}}.
\]
Following the above pattern, we define a new class as the closure of the parameterized weighted circuit evaluation problem under fixed-parameter parallelizable many-one reductions,
\[
\para \EP = \cl{\pWCE}^{\leq_m^{\para \NC}}
\]
(``E'' for evaluation).
\todo{This is a name conflict with an existing class called $\EP$.}

Since the underlying decision problem, the problem of evaluating a circuit on a given input, is in $\P$, the parameterized problem $\pWCE$ is trivially in $\para \P$.
Since $\para \NC$ reductions compose, $\para \NC$ is a subset of $\para \P$, and $\para \P$ is closed under $\para \P$ reductions, we conclude that $\para \EP$ is a subset of $\para \P$.

\begin{theorem}
  $\para \EP \subseteq \para \P$.
\end{theorem}

Is $\para \EP = \para \P$?
The standard simulation of a deterministic Turing machine by a circuit, as in \autocite{ladner75}, for example, fails to provide a $\para \NC$ many-one reduction to the parameterized weighted circuit evaluation problem, since the natural reduction would be of the form $x \mapsto (C, x, \|x\|_1)$, but the parameter value $\|x\|_1$ is not necessarily bounded by a function of $\kappa(x)$.
\todo{Show something bad happens if $\para \EP = \para \P$.}

\todo{Show a problem that is known to be in $\para \P$ (for example one of the deterministic Turing machine computation problems maybe) is actually in $\para \EP$.}

The same issue prevents us from showing that $\para \NC \subseteq \para \EP$.

\section{\texorpdfstring{$\para \NC$}{paraNC} is to \texorpdfstring{$\NC$}{NC} as \texorpdfstring{$\para \WNC$}{paraWNC} is to \texorpdfstring{$\NNC$}{NNC}}

\subsection{Definition of \texorpdfstring{$\para \WNC$}{paraWNC}}

\begin{definition}[{$\para \WNC^d$}]
  Let $d$ be a natural number.
  A parameterized problem $(Q, \kappa)$ is in the class $\para \WNC^d$ if there are circuit-computable functions $f$, $g$, and $h$, and a nondeterministic circuit family $\{C_{n, k}\}$ such that for each string $x$,
  \begin{itemize}
  \item $x \in Q$ if and only if $C_{n, k}(x) = 1$, where $n = |x|$ and $k = \kappa(x)$,
  \item $\size(C_{n, k}) \leq f(k) n^{O(1)}$,
  \item $\depth(C_{n, k}) \leq g(k) \log^d n$,
  \item $\nondet(C_{n, k}) \leq h(k) \log n$.
  \end{itemize}
\end{definition}

\subsection{Example problems in \texorpdfstring{$\para \WNC$}{paraWNC}}
\label{sec:rankinwp}

What kind of problems are in the class $\para \WNC$?

\begin{itemize}
\item The parameterized weighted Boolean formula satisfiability problem is in $\para \WNC^1$ \autocite[Theorem~3.6]{est15}.
\item The parameterized feedback vertex set problem is in $\para \WL$ \autocite[Section~4.3]{est15}, which is a subclass of $\para \WNC^2$.
\item The parameterized semigroup rank problem is in $\para \WNL$ \autocite[Theorem~3.12]{est15}, which is a subclass of $\para \WNC^2$.
\end{itemize}

Let us consider the parameterized group rank problem, a subset of the parameterized semigroup rank problem.

\begin{definition}[$\pgrouprank$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & finite group $G$ given as a product table, positive integer $k$. \\
    \textbf{Parameter:} & $k$. \\
    \textbf{Question:} & Does $G$ have a generating set of cardinality $k$?
  \end{tabular}
\end{definition}

This problem is highly parallelizable, given that a witness of size $O(k \log n)$ is provided.

\begin{theorem}\label{thm:pgrouprank}
  $\pgrouprank$ is in $\para \WL$.
\end{theorem}
\begin{proof}
  The Turing machine receives $G$ and $k$ as input and a subset $S$ of $k$ group elements as a witness.
  It loops over each element $g$ in $G$ and decides whether $g \in \gen{S}$.
  The machine accepts exactly when all of the subgroup membership tests pass.
  Looping over $n$ elements uses $O(\log n)$ space.
  Deciding whether $g$ is in $\gen{S}$ is the subgroup membership problem, which is in $\SL$, which in turn equals $\L$.
  Thus the overall space usage is $O(\log n)$.
  The size of the witness is $k \log n$, and two-way access is required, since we execute the subgroup membership procedure $n$ times.
  We conclude that this parameterized problem is in $\para \WL$.
\end{proof}

%% A related problem with a more natural parameterization is the weighted $\NC^d$ circuit satisfiability problem.
Let $\|x\|_1$ denote the Hamming weight (that is, the number of ones) of a binary string.
This problem is the restriction of $\pCSAT$ to bounded depth circuits.

\begin{definition}[$\pNCSAT$]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & Boolean circuit $C$ on $m$ inputs with depth $\log^d m$, natural number $k$. \\
    \textbf{Parameter:} & $k$. \\
    \textbf{Question:} & Is there a binary string $w$ such that $\|w\|_1 = k$ and $C(x) = 1$?
  \end{tabular}
\end{definition}

To prove membership in $\para \WNC^d$, we will use the following \emph{decoder function}.
Since we will also later use its inverse, the \emph{encoder function}, we define it here as well.

\begin{definition}\label{def:coding}
  The \emph{encoder function}, $E_n \colon \{0, 1\}^m \to \{0, 1\}^{\log m}$, is defined by
  \[
  E_m(x) =
  \begin{cases}
    i & \text{if } x \text{ has exactly one 1 at index } i \\
    0^{\log n} & \text{otherwise}.
  \end{cases}
  \]
  for each binary string $x$ of length $m$.
  The \emph{decoder function}, $D_m$, is defined as the inverse of the encoder function.
\end{definition}

\begin{lemma}\label{lem:codingbounds}
  For each natural number $m$, both the encoder and decoder functions are computable by a circuit of size $O(m)$ and depth $O(\log m)$.
\end{lemma}
\begin{proof}
  This can be found in, for example, Lemmas~2.5.3 and 2.5.4 of \autocite{savage98}.
\end{proof}

This theorem is an adaptation of \autocite[Lemma~3.3]{cc97lim}.

\begin{lemma}\label{lem:pkncsatmem}
  For each positive integer $d$, we have $\pNCSAT$ is in $\para \WNC^d$.
  Also, the underlying decision problem is in $\NNC^d[\poly]$.
\end{lemma}
\begin{proof}
  The underlying decision problem has a straightforward $\NNC^d[\poly]$ algorithm using the depth-universal circuit of \autocite{ch85}, along with a logarithmic depth circuit that enforces the inequality $\|w\|_1 = k$.
  The number of nondeterministic bits used by that circuit is $n$, the number of inputs to the circuit $C$, which is bounded above by the size of $C$.

  Membership in $\para \WNC^d$ requires a little more work.
  The algorithm will be composed of several subcircuits.
  \begin{itemize}
  \item Let $U$ be the depth-universal circuit \autocite{ch85} for depth $\log^d m$.
  \item Let $D_{m, k}$ be the function defined by $D_{m, k}(w) = D_m(w_1) \lor \dotsb \lor D_m(w_k)$, where $\lor$ denotes bitwise \textsc{or} for strings of length $m$, the binary string $w_i$ is the $i$th block of $w$ of size $\log m$, and $D_m$ is the decoder function (\autoref{def:coding}).
  %% The circuit $D_{m, k}$ interprets its input as $k$ blocks of length $\log m$ each, then outputs the string containing a one at index $i$ exactly when at least one block is the binary encoding of the natural number $i$.
  \item Let $\Delta$ be the function that takes $k$ blocks of $\log m$ bits each as input and evaluates to true exactly when each pair of blocks of size $\log m$ are distinct. For example, if $m = 4$, then $\Delta(0101) = 0$ but $\Delta(1011) = 1$.
  \end{itemize}
  Define the nonuniform, nondeterministic $\NC^d$ circuit family $\{A_{m, k}\}$ that decides $\pNCSAT$ by
  \[
  A_{n, k}((C, k), w) = U(C, D_{m, k}(w)) \land \Delta(w).
  \]
  In other words, $A_{n, k}$ interprets its witness string $w$ of length $k \log m$ as an encoding of a string of length $m$ containing \emph{exactly} $k$ ones (as enforced by $\Delta$), then evaluates the circuit $C$ on that string.

  This algorithm correctly decides the underlying decision problem.
  For each circuit $C$ of size $n$ and each integer $k$,
  \begin{align*}
    (C, k) \in \pNCSAT & \iff \exists x \in \{0, 1\}^m \colon \|x\|_1 = k \text{ and } C(x) = 1 \\
    & \iff \exists w \in \{0, 1\}^{k \log m} \colon (C(D_{m, k}(w)) \land \Delta(w)) = 1 \\
    & \iff \exists w \in \{0, 1\}^{k \log m} \colon (U(C, (D_{m, k}(w))) \land \Delta(w)) = 1 \\
    & \iff \exists w \in \{0, 1\}^{k \log m} \colon A_{n, k}((C, k), w) = 1.
  \end{align*}
  %% The number of nondeterministic bits used by $A_{n, k}$ is of the form $h(k) \log m$ if we choose $h$ to be the identity function.
  If we assume without loss of generality that $m \leq n$ (by padding with useless gates, for example), then the number of nondeterministic bits used is less than $k \log m$, which is of the form $h(k) \log n$.

  For the size and depth bounds, we need to determine the size and depth of the circuits for $U$, $D_{m, k}$, and $\Delta$.
  \begin{itemize}
  \item The depth-universal circuit $U$ has size $m^{O(1)}$ and depth $O(\log^d n)$, which is $O(\log^d m)$ because we can assume without loss of generality that the size of $C$ is at least the number of its inputs.
  \item
    Decoding a single block of size $\log m$ requires size $O(m)$ and depth $O(\log m)$ by \autoref{lem:codingbounds}.
    Decoding all $k$ blocks of size $\log m$ requires $k$ copies of that subcircuit, along with an \textsc{or} tree for each of the $m$ output bits.
    Thus the size of $D_{m, k}$ is $O(k m + m \log k)$ and the depth $O(\log m + \log k)$.
  \item
    Comparing two binary strings of length $\log m$ for inequality requires $O(\log m)$ size and $O(\log \log m)$ depth.
    Comparing all $\binom{k}{2}$ pairs of blocks and requiring they are all distinct thus requires a circuit of size $O(\binom{k}{2} \log m)$ and depth $O(\log m + \log k)$.
  \end{itemize}
  Hence the overall size of $A_{n, k}$ is of the form $f(k) m^{O(1)}$ and the depth $f(k) + \log^d m$.
  Since we can assume without loss of generality that $m \leq n$, we get size and depth bounds with the appropriate dependence on $k$ and $n$.

  Since we have shown a $\para \WNC^d$ circuit family deciding $\pNCSAT$, we conclude that the problem is in $\para \WNC^d$.
\end{proof}

\todo{Show a miniaturization of this problem?}

This technique also provides some alternate proofs that parameterized weighted Boolean formula satisfiability problem, denoted $\pFSAT$, is in $\para \WNC^1$, implicit in \autocite[Theorem~3.6]{est15}.
%% \todo{
%%   If we can show a reduction from parameterized formula satisfability to parameterized $\NC^1$ satisfiability, then we have yet another proof, although that's really the same as the one below.
%%   Each formula has an equivalent log depth circuit, but I need to ensure it is computable in $\AC^0$ (or $\FO$).
%% }
The first proof is a reduction to $p \dash k \dash \NC^1 \textsc{Csat}$, and requires two auxiliary algorithms.

\begin{lemma}[{\autocite{lsh65}}]
  There is an $\NC^1$ algorithm that, given a binary tree $T$ on $n$ leaves, finds a subtree on $s$ leaves, where $\frac{1}{3} n \leq s \leq \frac{2}{3} n$.
\end{lemma}
\begin{proof}
  The naïve implementation of the procedure from \autocite{lsh65} would require repeatedly computing the number of leaves in each subtree.
  Instead, we compute the number of leaves in each subtree once at the beginning of the algorithm.

  The algorithm proceeds as follows.
  Compute $\frac{1}{3} n$ and $\frac{2}{3} n$.
  Compute for each node, the number of leaves in the subtree rooted at that node.
  Output the subtree that is within the bounds (one must exist by a counting argument).

  Division and multiplication of integers of length $\log n$ can certainly be done by a circuit of size $O(n)$ and depth $O(\log n)$.
  Computing the number of leaves in each subtree can be done by first computing the number of direct children of each node with a circuit of size $O(n)$ and depth $O(1)$, then performing a prefix-sum operation (only on those prefixes that are paths in the tree) with size $O(n)$ and depth $O(\log n)$ (see \autocite[Theorem~2.6.1]{savage98} for a prefix-sum implementation).
  Comparing each of these numbers to the computed upper and lower bounds requires size $O(n \log n)$ and depth $O(\log \log n)$.
  Finally, outputing the node requires depth $O(1)$, or, if the entire subtree is desired, depth $O(\log n)$ by using a path-doubling algorithm to find each node in the subtree rooted at the given node.

  Overall, the algorithm can be implemented by a circuit of size $n^{O(1)}$ and depth $O(\log n)$.
\end{proof}

\todo{find a copy of \autocite{spira71}}

\begin{lemma}[{\autocite{spira71} (see also \autocite[Theorem~2]{bb94})}]\label{lem:logformula}
  There is an $\NC^1$ algorithm that transforms a Boolean formula of size $n$ into a Boolean formula of size $n^{O(1)}$ and depth $O(\log n)$.
\end{lemma}
\begin{proof}
  Let $A'$ be the algorithm of the previous lemma that finds a subtree of size approximately $n / 2$.
  Construct the algorithm $A$ that proceeds as follows on input $\phi$ of size $n$.
  \todo{Modify this, because it doesn't work: computing A' repeatedly is too much; we can just compute the mapping from node to size of subtree and update it when replacing $\psi$ with 1 or 0.}
  \begin{itemize}
  \item Let $\psi = A'(\phi)$.
  \item Let $\phi' = (\psi \land \phi|_{\psi = 1}) \lor (\lnot \psi \land \phi|_{\psi = 0})$, where $\phi|_{\psi = b}$ denotes the formula $\phi$ with each instance of $\psi$ replaced with the constant $b$.
  \item Apply $A$ recursively to each of the four subformulas in $\phi'$ and return the resulting formula.
  \end{itemize}
  ...
\end{proof}

\begin{lemma}[{\autocite[Theorem~3.6]{est15}}]\label{lem:pfsatmem}
  $\pFSAT$ is in $\para \WNC^1$.
  Also, the underlying decision problem is in $\NNC^1[\poly]$.
\end{lemma}
\begin{proof}
  We show a $\para \NC^1$ many-one reduction to the weighted circuit satisfiability for logarithmic depth circuits.
  By \autoref{lem:logformula}, each Boolean formula $\phi$ of size $n$ can be transformed into an equivalent Boolean formula $\phi'$ of depth $O(\log n)$.
  From there, we simply output the circuit representation $C$ of that logarithmic depth formula.
  Furthermore, the formula $\phi'$ has the property that $\phi(x) = \phi'(x)$ for each assignment $x$, and the circuit $C$ has the property that $\phi'(x) = C(x)$ for each $x$.
  Thus the reduction is correct: $\phi$ has a satisfying assignment of weight exactly $k$ if and only if $\phi'$ does if and only if $C$ does.
  Since the reduction is computable in $\NC^1$ and the parameter is identical, it is trivially computable in $\para \NC^1$.
\end{proof}

The second proof directly implements the decoder function of \autoref{def:coding} as a Boolean formula.

\begin{proof}[Alternate proof of \autoref{lem:pfsatmem}]
  The underlying decision problem has a straightforward $\NNC^1[\poly]$ algorithm using the $\NC^1$ algorithm for Boolean formula satisfiability \autocites{buss87, bcgr92}, along with a logarithmic depth circuit that enforces the inequality $\|w\|_1 = k$.
  The number of nondeterministic bits used by the circuit is the number of variables in the formula, which is bounded above by a polynomial in the size of the formula.

  We adapt the ``$k \log n$ trick'' from circuit inputs to formula variables.
  This requires a reimplementation of the decoder function of \autoref{def:coding} as a function on Boolean variables.

  Similar to the proof of \autoref{lem:pkncsatmem}, the algorithm involves composing a decoder and an algorithm for evaluating a Boolean formula, after nondeterministically choosing a witness.
  Again, we use some subcircuits:
  \begin{itemize}
  \item Let $U$ be the $\NC^1$ algorithm for evaluating a Boolean formula \autocites{buss87, bcgr92}.
  \item
    Let $M_i$ be the function on $\log m$ that outputs the $i$th minterm of its input variables (for example, $M_4(w_1, w_2, w_3) = w_1 \land \lnot w_2 \land \lnot w_3$).
    This function acts like the decoder in \autoref{lem:pkncsatmem}.
  \item
    Let $R_{m, k}(\phi)$ be the function that replaces each instance of a variable $x_i$ in a Boolean formula $\phi$ on $m$ variables with $\vee_{j = 1}^k M_i(\vec{v}_j)$, where $\vec{v}_j$ denotes the $j$th block of size $\log m$ in a tuple of $k \log m$ new variables $v_1, \dotsc, v_{k \log m}$.
  \item Let $\Delta$ be the function that takes $k$ blocks of $\log m$ bits each as input and evaluates to true exactly when each pair of blocks of size $\log m$ are distinct.
  \end{itemize}
  Define the nonuniform, nondeterministic $\NC^1$ circuit family $\{A_{n, k}\}$ that decides $\pFSAT$ by
  \[
  A_{n, k}((\phi, k), w) = U(R_{m, k}(\phi), w) \land \Delta(w).
  \]
  In other words, $A_{n, k}$ interprets its witness string $w$ of length $k \log m$ as the \emph{encoding of an assignment} to the variables of $\phi$ in which exactly $k$ variables are set to true, then evaluates the formula $\phi$ with respect to the decoded assignment.

  This algorithm correctly decides the weighted Boolean formula satisfiability problem.
  Similar to the proof of \autoref{lem:pkncsatmem}, $\phi$ has a satisfying assignment of weight exactly $k$ if and only if $\phi'$ has a satisfying assignment (of arbitrary weight).
  If we assume without loss of generality that $m \leq n$ (by padding with tautological conjuncts, for example), then the number of nondeterministic bits used is less than $k \log m$, which is of the form $h(k) \log n$.

  The algorithm also has the appropriate size and depth bounds.
  Since each minterm is of size exactly $\log m$ and each variable $x_i$ is represented the disjunction of $k$ such minterms, the new formula $\phi'$ is of size $|\phi| k \log m$, which is just $n k \log m$.
  \begin{itemize}
  \item
    Each variable $x_i$ can be replaced in parallel, and within that replacement, each disjunct $M_i(\vec{w}_j)$ can be replaced in parallel as well.
    The circuit that writes $M_i(\vec{w}_j)$ is a circuit of size $O(\log m)$ and depth $O(\log m)$ (for using the index $i$ as a selector in a multiplexer), so $R_{m, k}$ can be implemented by a circuit of size $O(n k \log m)$ and depth $O(\log m)$.
  \item
    The circuit $U$ receives a formula of size $O(n k \log m)$ and an assignment of length $O(k \log m)$.
    Since $U$ is a circuit of size polynomial in its the size of its input, its size is $O((n k \log m)^c)$ for some constant $c$.
    Similarly, its depth is $O(\log^d (n k \log m))$.
  \item As in \autoref{lem:pkncsatmem}, the circuit for $\Delta$ is of size $O(\binom{k}{2} \log m)$ and depth $O(\log m + \log k)$.
  \end{itemize}
  The overall size and depth of the circuit $A_{n, k}$ are therefore of the form $f(k) n^{O(1)}$ and $f(k) + O(\log^d n)$, respectively.
  \todo{Add info in the introduction about why we can assume, since $k$ is smaller than $O(\log n)$, that $O(\log^d nk) \leq f(k) + O(\log^d n)$.}

  At this point, we have shown a correct $\para \WNC^1$ algorithm for $\pFSAT$.
\end{proof}

The same proof works for the problems of deciding whether a circuit or a formula has a satisfying assignment of weight \emph{at most} $k$, as well (one could even remove the $\Delta$ subcircuit entirely, but that is not necessary).

\subsection{Completeness in \texorpdfstring{$\para \WNC$}{paraWNC}}

We saw that the parameterized weighted Boolean formula satisfiability problem, $\pFSAT$, is in $\para \WNC^1$ in \autoref{lem:pfsatmem}.
In fact, it is complete for $\para \WNC^1$ under $\para \FO$ many-one reductions \autocite[Theorem~3.6]{est15}.
\todo{Can we use the ``template on top of a verification language'' elsewhere?}
The parameterized weighted Boolean circuit satisfiability problem, denoted $\pCSAT$, is the same problem with Boolean circuits instead of Boolean formulas; this problem is complete for $\para \WP$ under $\para \FO$ many-one reductions by a similar proof.
It makes sense to expect, then, that the problems $\pNCSAT$ may be complete for the classes $\para \WNC^d$, for each positive integer $d$.

%% One strategy for proving complete problems for the $\para \WNC^d$ classes might be to adapt the proof of the $\para \WNC^1$-completeness of $\pFSAT$.
%% Since Boolean formulas are equivalent to Boolean circuits of logarithmic depth \todo{add citation}, the $\pFSAT$ can be viewed as $p \dash k \dash \NC^1 \textsc{CSat}$.
%% However, the proof of \autocite[Theorem~3.6]{est15} does not translate directly to the setting of bounded depth circuit satisfiability (their reduction would yield a circuit of depth greater than polylogarithmic in the number of inputs).
In order to prove completeness for these problems, we use the strategy from \autocite[Theorem~3.6]{cc97lim}, which relies on the ``$k \log n$ trick'' (see \autocite[Corollary~3.13]{fg06}, or the origin \autocite{adf95}).
There the authors prove that the decision problem underlying $\pNCSAT$ is complete for $\NNC^d[k \log n]$.
As we will see in the next section (and repeatedly throughout this paper), parameterized complexity and limited nondeterminism in decision complexity are closely related.

\begin{theorem}\label{thm:parawncdcomplete}
  For each positive integer $d$, we have $\pNCSAT$ is complete for $\para \WNC^d$ under $\para \NC^1$ many-one reductions.
  Also, the underlying decision problem is in $\NNC^d[\poly]$.
\end{theorem}
\begin{proof}
  Membership in $\para \WNC^d$ (and in $\NNC^d[\poly]$ for the underlying decision problem) was proven in \autoref{lem:pkncsatmem}.

  Suppose $(Q, \kappa)$ is in $\para \WNC^d$, so there is a nonuniform $\NC^d$ circuit family $\{C_{n, k}\}$ and circuit-computable functions $f$ and $h$ such that
  \begin{itemize}
  \item $x \in Q$ if and only if $C_{n, k}(x) = 1$,
  \item $\size(C_{n, k}) \leq f(k) n^{O(1)}$,
  \item $\depth(C_{n, k}) \leq f(k) + O(\log^d n)$,
  \item $\nondet(C_{n, k}) \leq h(k) \log n$.
  \end{itemize}
  On input $x$ of length $n$, let $C_x$ denote the circuit $C_{n, k}$ with $x$ hardcoded as its first $n$ inputs.
  Thus $C_x$ is a circuit with $h(k) \log n$ inputs such that $x \in Q$ if and only if $C_x$ is satisfiable.
  Let $E_{n, k}$ denote the function defined by $E_{n, k}(w) = E_n(w_1) \circ \dotsb \circ E_n(w_{h(k)})$, where $\circ$ denotes string concatenation, $E_n$ is the encoder function of \autoref{def:coding}, and $w_i$ is the $i$th block of size $n$ in the string $w$, for each string $w$ of length $h(k) n$.
  The reduction is then $x \mapsto (C', h(k))$, where $C' = C_x \circ E_{n, k}$.

  The circuit $C'$ is of the correct form to be an input to $\pNCSAT$.
  The size of $C'$ is
  \begin{align*}
    \size(C') & = \size(E_{n, k}) + \size(C_x) \\
    & \leq h(k) \size(E_n) + f(k) n^{O(1)} \\
    & \leq h(k) O(n) + f(k) n^{O(1)}
  \end{align*}
  and the depth
  \begin{align*}
    \depth(C') & = \depth(E_{n, k}) + \depth(C_x) \\
    & \leq \depth(E_n) + (f(k) + \log^d n) \\
    & \leq O(\log n) + f(k) + \log^d n \\
    & \leq f(k) + O(\log^d n).
  \end{align*}
  The number of inputs to $C'$ is $h(k) n$, so we need the size to be polynomial in $h(k) n$ and the depth to be $\log^d (h(k) n)$.
  The size bound is satisfied if we choose $h(k)$ so that $f(k) \leq h(k)$ and the depth bound satisfied if we choose $h(k)$ so that $f(k) \leq \log^d h(k)$, ignoring some constants that can be incorporated into the function $h$.
  We can choose $h$ this way without loss of generality, because choosing a larger $h$ does not affect membership of $(Q, \kappa)$ in $\para \WNC^d$.
  (This does, however, cause the nondeterminism upper bound of the problem $(Q, \kappa)$ to be extremely loose and the dependence on $k$ in the size and depth bounds of $C'$ to be extremely high, but it is technically sufficient.)

  The reduction is a correct many-one reduction between the underlying decision problems.
  Suppose $x \in Q$, so $C_x$ is satisfiable.
  Since $E_n$ is surjective, so is $E_{n, k}$, hence there is a string $w$ (of length $h(k) n$) such that $C'(w) = 1$.
  Furthermore, this string satisfies $\|w\|_1 = h(k)$ since all preimages of $E_{n, k}$ satisfy this equality.%
  \footnote{%
    Technically, we need to guarantee the satisfying input to $C_x$ has no all-zero blocks to make this statement.
    For each parameterized problem $(Q, \kappa)$ there is another equivalent problem that satisfies such a requirement on the witnesses for $Q$ with no change in complexity.%
  }
  Therefore, $C'$ has a satisfying assignment of Hamming weight exactly $h(k)$.
  For the converse, suppose $C'$ has a satisfying assignment $w$ of weight exactly $h(k)$.
  Then there is a satisfying assignment of length $h(k) \log n$ for $C_x$, namely $E_{n, k}(w)$.
  Therefore, $x$ is in $Q$.

  The reduction is $\para \NC^1$-computable.
  The size of the circuit computing the reduction is simply the size of the output, which is $\size(C') + \size(h_k)$, where $h_k$ denotes the circuit computing $h$ on inputs of size $k$.
  Both addends are of the form $f'(k) n^{O(1)}$ for some circuit-computable function $f'$.
  The depth of the circuit computing the reduction is dominated by the depth of the $h_k$, which is bounded above by $f'(k) + \log n$ for some function $f'$.
  Thus the size and depth requirements for the reduction are met.
  Finally, if $R$ denotes the reduction and $\kappa'$ denotes the parameterization for $\pNCSAT$,
  \[
  \kappa'(R(x)) \leq \kappa'((C', h(\kappa(x)))) = h(\kappa(x)).
  \]
  Since $h$ is circuit-computable by hypothesis, the reduction meets the parameterization bound.

  Since we have shown a correct $\para \NC^1$ many-one reduction from an arbitrary parameterized problem in $\para \WNC^d$ to $\pNCSAT$, we conclude that $\pNCSAT$ is complete for the class.
\end{proof}

This technique also gives us an alternate proof of the completeness $\pFSAT$ \autocite[Theorem~3.6]{est15}.
However, we can prove only completeness under the $\para \NC^1$ reduction instead of the tighter $\para \FO$ reduction.

\begin{theorem}\label{thm:pfsatcomplete}
  $\pFSAT$ is complete for $\para \WNC^1$ under $\para \NC^1$ many-one reductions.
  Also, the underlying decision problem is in $\NNC^1[\poly]$.
\end{theorem}
\begin{proof}
  Membership in $\para \WNC^1$ (and in $\NNC^1[\poly]$ for the underlying decision problem) was proven in \autoref{lem:pfsatmem}.

  To prove hardness, it suffices to show a $\para \NC^1$ reduction from $p \dash k \dash \NC^1 \textsc{CSat}$ to $\pFSAT$, since the circuit problem is complete for $\para \WNC^1$ by the previous theorem.
  The reduction is $(C, k) \mapsto (\phi, k)$, where $\phi$ is the standard reduction for logarithmic depth circuits to polynomial size Boolean formulas.
  This reduction recursively replaces each subcircuit with its corresponding formula, using the input gates of the circuit as the variables for the formula.
  Since the depth of the (fan-in 2) circuit is $O(\log n)$, where $n$ is the number if inputs to $C$, the size of the formula is $2^{O(\log n)}$, which is polynomial in $n$.
  Furthermore, since the variables appearing in the formula are exactly the input gates of the circuit, the circuit has a satisfying assignment of weight $k$ if and only if the formula has a satisfying assignment of weight $k$.
  Finally, the reduction is computable by circuit of size $O(|\phi|)$ and depth $O(\depth(C))$, so it is computable in $\NC^1$ \todo{someone verify this}.
  Since furthermore the parameter is unchanged by the reduction, the $\NC^1$-computable function trivially induces a $\para \NC^1$ reduction.
\end{proof}

Now we have a full interpolation for the inclusion chain
\[
\para \WNC^1 \subseteq \para \WNC^2 \subseteq \dotsb \subseteq \para \WP,
\]
via the chain of parameterized reductions between corresponding complete problems
\[
\pFSAT \leq p \dash k \dash \NC^2 \textsc{CSat} \leq \dotsb \leq p \dash \textsc{CSat}.
\]
Whether the $\pNCSAT$ problems are complete under $\para \FO$ many-one reductions remains open.

\subsection{Does \texorpdfstring{$\para \NC$}{paraNC} equal \texorpdfstring{$\para \WNC$}{paraWNC}?}
\label{sec:fppwpp}

The main theorem in this section, \autoref{thm:ncwnc}, provides evidence that the parameterized complexity classes $\para \NC$ and $\para \WNC$ are distinct.
Compare it with the following similar theorems (here $\beta$ indicates one-way access to the witness as opposed to $\W$, which indicates two-way access).
\begin{itemize}
\item $\para \P = \para \WP$ if and only if $\P = \NP[\omega(\log n)]$ \autocite[Theorem~3.29]{fg06}.
\item $\para \L = \para \beta \L$ if and only if $\L = \NL[\omega(\log n)]$ \autocite[Theorem~15]{cm14}.
\end{itemize}
\todo{Can we generalize all of these theorems?}

The next theorem is similar to \autoref{thm:eventually} in that it is a characterization of $\para \WNC^d$, a nondeterministic extension of $\para \NC^d$.
It is the adaptation of \autocite[Proposition~3.7]{fg06}.
The parameterized problems in $\para \WNC^d$ of most interest to us are those for which there is a nondeterministic $\NC$ algorithm with nondeterminism limited by a function of the parameter.
Compare this with \autoref{lem:reducetonc}.
\todo{Can they be generalized?}

\begin{theorem}\label{thm:rmparam}
  Suppose $d$ is a positive integer and $(Q, \kappa)$ is a parameterized problem.
  If $(Q, \kappa) \in \para \WNC^d$ and $Q \in \NNC^d[\poly]$, then there is a nondeterministic $\NC^d$ circuit family $\{C_{n, k}\}$ and a circuit-computable function $h$ such that $\{C_{n, k}\}$ decides $Q$ and $\nondet(C_{n, k}) \leq h(k) \log n$.
  %% The converse holds when $e = 0$.
\end{theorem}
\begin{proof}
  Assume $(Q, \kappa) \in \para \WNC^d$ and $Q \in \NNC^d[\poly]$.
  Define the circuit family $\{A_{n, k}\}$ by
  \[
  A_{n, k} =
  \begin{cases}
    C^1_{n, k} & \text{if } f(k) \leq \min(n, \log^d n) \\
    C^2_n & \text{otherwise},
  \end{cases}
  \]
  where
  \begin{itemize}
  \item $\{C^1_{n, k}\}$ is the $\para \WNC^d$ circuit family,
  \item $f$ is the circuit-computable function on the parameter that appears in the size and depth bounds for $C^1_{n, k}$,
  \item $\{C^2_n\}$ is the $\NNC^d[\poly]$ circuit family.
  \end{itemize}
  The fact that $A_{n, k}$ correctly decides $Q$ follows from the correctness of the circuits $C^1_{n, k}$ and $C^2_n$.
  It remains to show that $A_{n, k}$ has the required size, depth, and nondeterminism bounds.

  If $f(k) \leq \min(n, \log^d n)$, then
  \begin{align*}
    \size(A_{n, k}) & \leq \size(C^1_{n, k}) \leq f(k) n^{O(1)} \leq n^{O(1)} \\
    \depth(A_{n, k}) & \leq \depth(C^1_{n, k}) \leq f(k) + O(\log^d n) \leq O(\log^d n),
  \end{align*}
  and otherwise
  \begin{align*}
    \size(A_{n, k}) & \leq \size(C^2_n) \leq n^{O(1)} \\
    \depth(A_{n, k}) & \leq \depth(C^2_n) \leq O(\log^d n).
  \end{align*}
  The overall size and depth upper bounds for $A_{n, k}$ are thus $n^{O(1)}$ and $O(\log^d n)$, respectively.

  For the nondeterminism, there are three cases.
  First, if $f(k) \leq n$ and $f(k) \leq \log^d n$, then
  \[
  \nondet(A_{n, k}) \leq \nondet(C^1_{n, k}) \leq h(k) \log n,
  \]
  where $h$ is the circuit-computable of the parameter that appears in the nondeterminism bound for $C^1_{n, k}$.
  Second, if $f(k) > n$, then
  \[
  \nondet(A_{n, k}) \leq \nondet(C^2_n) \leq n^{O(1)} \leq f(k)^{O(1)}.
  \]
  Finally, if $f(k) > \log^d n$, then $2^{f(k)^{1 / d}} > n$, which implies
  \[
  \nondet(A_{n, k}) \leq \nondet(C^2_n) \leq n^{O(1)} \leq 2^{O\left(f(k)^{1 / d}\right)}.
  \]
  If we choose $h$ to be the computable function
  \[
  h(k) = \max \left\{ h(k), f(k)^{O(1)}, 2^{O\left(f(k)^{1 / d}\right)} \right\},
  \]
  then we can conclude $\nondet(A_{n, k}) \leq h(k) \log n$.
  (Since we assume $d$ is positive, the quotient $1 / d$ is well-defined.)
\end{proof}

This lemma is an adaptation of \autocite[Lemma~3.24]{fg06}.
It is the ``opposite'' of \autoref{lem:upperinverse}.

\begin{lemma}\label{lem:lowerinverse}
  Suppose $d$ is a positive integer.
  For each increasing, circuit-computable function $f$, there is a function $i_{f, d}$ such that
  \[
  f(i_{f, d}(n)) \leq \min(n, \log^d n)
  \]
  for each $n \geq f(1)$.
  Furthermore, $i_{f, d}$ is circuit-computable, nondecreasing, unbounded.
\end{lemma}
\begin{proof}
  Define $i_{f, d}$ by
  \[
  i_{f, d}(n) = \max\{ j \in \mathbb{N} \, | \, f(j) \leq \min(n, \log^d n) \}.
  \]
  For the boundary case where $n$ is smaller than $f(1)$, define $i_{f, d}(n) = 1$.
  It is straightforward to prove that this function is nondecreasing and unbounded.
  (The integer $d$ must be greater than zero to guarantee $i_{f, d}$ is unbounded.)

  To compute $i_{f, d}$, we use the fact that $f$ is increasing to perform a binary search on the values $f(1), \dotsc, f(\min(n, \log^d n))$ and to determine the largest $j$ such that $f(j) \leq \min(n, \log^d n)$.
  In the worst case, there will be at most $\log n$ comparison subcircuits, each requiring a computation of $f$, so the overall depth of the circuit computing $i_{f, d}$ is $O(\depth(f) \log n)$ and the size is $O(\size(f) \log n)$.
\end{proof}

This theorem is an adaptation of \autocite[Theorem~3.29]{fg06}.
For any computable function $i$, let $i(n) \dash \NC^d \dash \textsc{CSat}$ denote the problem of deciding whether a depth $O(\log^d n)$ circuit is satisfiable by an input of Hamming weight at most $i(n)$.
This problem is complete for $\NNC^d[i(n) \log n]$ under logarithmic space many-one reductions \autocite[Theorem~3.6]{cc97lim}.

\begin{theorem}\label{thm:ncwnc}
  Suppose $d$ is a positive integer.
  $\para \NC^d = \para \WNC^d$ if and only if there is a circuit-computable, nondecreasing, unbounded function $i$ such that $\NC^d = \NNC^d[i(n) \log n]$.
\end{theorem}
\begin{proof}
  First we prove the reverse implication.
  Assume $\NC^d = \NNC^d[i(n) \log n]$, for some $i$.
  We will show that $\pNCSAT$, a problem complete for $\para \WNC^d$ by \autoref{thm:parawncdcomplete}, is now in $\para \NC^d$, which necessitates the claimed collapse.
  Since this problem is also in $\NNC^d[\poly]$, \autoref{thm:rmparam} guarantees the existence of a circuit-computable function $h$ and an $\NNC^d$ circuit family $\{C_{n, k}\}$ such that $\nondet(C_{n, k}) \leq h(k) \log n$.

  Let $f$ be a circuit-computable function such that $n \geq f(k)$ implies $h(k) \leq i(n)$.
  \todo{Explain why such an $f$ must exist; using \autoref{lem:upperinverse} or \autoref{lem:lowerinverse}?}
  Now consider the set $Q^+$, defined by
  \[
  Q^+ = Q \cap \left\{ x \, \middle| \, |x| \geq f(\kappa(x)) \right\}.
  \]
  Since $|x| \geq f(\kappa(x))$ for each $x \in Q^+$, we have $h(\kappa(x)) \leq i(|x|)$.
  Thus $Q^+$ is in $\NNC^d[i(n) \log n]$.
  By assumption, $Q^+$ is therefore also in $\NC^d$.
  This means $Q$ is eventually in $\NC^d$, so we have $Q \in \para \NC^d$ by \autoref{thm:eventually}.

  Now we prove the forward implication.
  Assume $\para \NC^d = \para \WNC^d$.
  By \autoref{thm:parawncdcomplete}, the parameterized problem $\pNCSAT$ is now in $\para \NC^d$.
  Let $\{A_{n, k}\}$ be the $\para \NC^d$ circuit family that decides this problem, with size bound $f(k) n^{O(1)}$ and depth bound $f(k) + \log^d n$, for some circuit-computable function $f$.
  Assume without loss of generality that $f$ is increasing.
  Choose $i$ to be the ``lower inverse'' function $i_{f, d}$ guaranteed by \autoref{lem:lowerinverse}.

  The decision problem $i(n) \dash \NC^d \dash \textsc{CSat}$ is complete for $\NNC^d[i(n) \log n]$ under logarithmic space many-one reductions by \autocite[Theorem~3.6]{cc97lim}, so it suffices to show that this problem is in $\NC^d$.
  \todo{Need to show the case $d = 1$ works as well.}
  The circuit family $\{A'_n\}$ defined by $A'_n(C) = A_{n, i(n)}((C, i(n)))$ witnesses this membership:
  \[
  \size(A'_n) = \size(A_{n, i(n)}) \leq f(i(n)) n^{O(1)} \leq n^{O(1)}
  \]
  and
  \[
  \depth(A_n) = \depth(A_{n, i(n)}) \leq f(i(n)) + O(\log^d n) \leq O(\log^d n),
  \]
  by the way $i$ was chosen.
  The correctness of this algorithm follows from the correctness of $A_{n, k}$.
  Since we have shown an $\NC^d$ algorithm for an $\NNC^d[i(n) \log n]$-complete problem, we conclude that $\NC^d = \NNC^d[i(n) \log n]$.
\end{proof}

As a corollary, any problem complete for $\para \WNC^d$ is not in $\para \NC^d$ unless $\NC^d = \NNC^d[i(n) \log n]$.

\begin{corollary}
  For each positive integer $d$, we have $\pNCSAT$ is in $\para \NC^d$ if and only if there is a circuit-computable, nondecreasing, unbounded function $i$ such that $\NC^d = \NNC^d[i(n) \log n]$.
  (Here we equate $\NC^1 \dash \textsc{CSat}$ with $\textsc{FSat}$.)
\end{corollary}

\subsection{Is \texorpdfstring{$\para \WNC$}{paraWNC} in \texorpdfstring{$\para \P$}{paraP}?}
\label{sec:wncp}

The previous section demonstrates that it is unlikely that $\para \WNC$ is contained in $\para \NC$.
Does the weaker inclusion of $\para \WNC$ in $\para \P$ also have negative consequences, albeit less severe ones?
This conjecture relaxes \autoref{thm:ncwnc}.

\begin{conjecture}\label{con:wncp}
  $\para \WNC^d \subseteq \para \P$ if and only if $\NNC^d[i(n) \log n] \subseteq \P$.
\end{conjecture}

Here is an alternate approach that connects a collapse in parameterized complexity classes to one in classical complexity classes.

\begin{theorem}[{\autocite[Corollary~3.7]{est15}}]
  If $\NC^1 = \P$, then $\W[\SAT] = \para \WP$.
\end{theorem}

As in \autoref{thm:parawncdcomplete}, we wish to generalize this theorem so that we have an interpolation between $\NC^1$ and $\P$.
%% Writing ``$\P$'', the upper limit of the interpolation, in place of ``$\NC^d$'' on the left gives $\para \WP = \para \WP$ on the right, a tautology.

\begin{conjecture}
  For each positive integer $d$, if $\NC^d = \P$, then $\W[\NC^d \SAT] = \para \WP$.
\end{conjecture}

An alternative approach is to demonstrate related collapses in parameterized complexity classes.

\begin{theorem}[{\autocite[Corollary~3.8]{est15}}]
  $\para \WNC^1 \subseteq \para \P$ if and only if $\para \P = \W[\SAT]$.
\end{theorem}

Here we interpolate between $\para \WNC^1$ and $\para \WP$.
%% Writing ``$\para \WP$'' in place of ``$\para \WNC^d$'' on the left, the upper limit of the interpolation, gives $\para \P = \para \WP$ on the right, a tautology.

\begin{conjecture}
  For each positive integer $d$, we have $\para \WNC^d \subseteq \para \P$ if and only if $\para \P = \W[\NC^d \SAT]$.
\end{conjecture}

\subsection{Does \texorpdfstring{$\para \WNC$}{paraWNC} equal \texorpdfstring{$\para \WP$}{paraWP}?}
\label{sec:wncwp}

\begin{conjecture}
  For each positive integer $d$, if $\para \WNC^d = \para \WP$, then $\NC^d = \P$.
\end{conjecture}
\begin{justification}
  $p \dash k \dash \textsc{CSat}$ is $\para \WP$-complete and $p \dash \textsc{FSat}$ is $\para \WNC^1$-complete \autocite[Theorem~3.6]{est15}.
  A reduction from the former to the latter would be very surprising.
\end{justification}

\section{The \texorpdfstring{$\para \WNC$}{paraWNC} hierarchy}

For the necessary background in logic, see \autocite[Chapter~4]{fg06}.

\subsection{Definition of \texorpdfstring{$\para \WNC[t]$}{paraWNC[t]}}

Let $\Phi$ be a class of formulas and let $\phi$ be an element of $\Phi$ with one free relation variable $X$ of arity $s$.
Define the parameterized weighted definability problem as follows.

%% \begin{definition}[{$\WD_\phi$ \autocite[Section~4.3]{fg06}}]
%%   \mbox{} \\
%%   \begin{tabular}{r p{9.2cm}}
%%     \textbf{Instance:} & structure $\mathcal{A}$, natural number $k$. \\
%%     \textbf{Question:} & Is there an $S \subseteq A^s$ such that $|S| = k$ and $\mathcal{A} \models \phi(S)$?
%%   \end{tabular}
%% \end{definition}

\begin{definition}[{$p \dash \WD_\phi$ \autocite[Section~5.1]{fg06}}]
  \mbox{} \\
  \begin{tabular}{r p{9.2cm}}
    \textbf{Instance:} & structure $\mathcal{A}$, natural number $k$. \\
    \textbf{Parameter:} & $k$ \\
    \textbf{Question:} & Is there an $S \subseteq A^s$ such that $|S| = k$ and $\mathcal{A} \models \phi(S)$?
  \end{tabular}
\end{definition}

Let $p \dash \WD \dash \Phi$ be the class of all problems $p \dash \WD_\phi$ where $\phi$ is in $\Phi$.

\todo{
  Using closure under $\para \NC^1$ reductions just gives the $\para \WP[t]$ classes, since $\para \WP[t]$ is probably just the closure under first-order reductions.
  We may have to use a weft-based definition here.
}

%% This definition is adapted from \autocite[Definition~5.1]{fg06}.

%% \begin{definition}
%%   For each positive integer $d$ greater than one and each positive integer $t$, let $\para \WNC^d[t] = \cl{p \dash \WD \dash \Pi_t}^{\leq_m^{\para \NC^1}}$.
%% \end{definition}

%% This theorem is adapted from \autocite[Proposition~5.3]{fg06}.

%% \begin{conjecture}
%%   For each positive integer $d$ greater than one and each positive integer $t$, we have $\para \WNC^d[t] \subseteq \para \WNC^d$.
%% \end{conjecture}

%% %% These definitions are used for the A[t] and A[P] hierarchy.

%% \begin{definition}[{$\MC(\Phi)$ \autocite[Section~4.3]{fg06}}]
%%   \mbox{} \\
%%   \begin{tabular}{r p{9.2cm}}
%%     \textbf{Instance:} & structure $\mathcal{A}$, formula $\phi \in \Phi$. \\
%%     \textbf{Question:} & Does $\mathcal{A} \models \phi$?
%%   \end{tabular}
%% \end{definition}

%% \begin{definition}[{$p\textnormal{-}\MC(\Phi)$ \autocite[Section~5.2]{fg06}}]
%%   \mbox{} \\
%%   \begin{tabular}{r p{9.2cm}}
%%     \textbf{Instance:} & structure $\mathcal{A}$, formula $\phi \in \Phi$. \\
%%     \textbf{Parameter:} & $|\phi|$ \\
%%     \textbf{Question:} & Does $\mathcal{A} \models \phi$?
%%   \end{tabular}
%% \end{definition}

\subsection{Example problem in \texorpdfstring{$\para \WNC[t]$}{paraWNC[t]}}

\todo{Show a natural problem in some $\para \WNC[t]$, perhaps a weft-restricted $\NC^d$ circuit satisfiability problem.}

In \autoref{sec:rankinwp}, we proved that $\pgrouprank$ is in $\para \WNC^2$.
This problem may not be in $\para \WNC^2[t]$ for some finite $t$.
%% Let us try to express this problem in first-order logic.
%%
%% \begin{definition}[Axiomatization of groups]
%%   The signature for groups has a constant symbol for the identity element denoted $e$, a unary function for the inverse denoted $x^{-1}$, and a binary function for the group operation (denoted by concatenation).
%%   Let the group axioms be defined as first-order formulae as follows.
%%   \begin{align*}
%%     \textsc{HasIdentity} & = \forall x\, (ex = x \land xe = x) \\
%%     \textsc{HasInverses} & = \forall x\, (x^{-1} x = x x^{-1} = e) \\
%%     \textsc{IsAssociative} & = \forall x \forall y \forall z\, ((x y) z = x (y z))
%%   \end{align*}
%%   Let $\textsc{IsGroup}$ be the conjunction of these three formulae.
%%   Now for any finite structure $\mathcal{A}$, we have $\mathcal{A} \models \textsc{IsGroup}$ if and only if $\mathcal{A}$ is a group.
%%   Let $\textsc{Group}$ denote the class of all finite structures that are valid groups, that is, the class of all structures that model $\textsc{IsGroup}$.
%%   (Since the universal quantifiers can be placed in the beginning of the formula, $\textsc{IsGroup}$ is a $\Pi_1$ formula.)
%% \end{definition}
Unfortunately, the best first-order formulas that describe this problem are not of the form $\Sigma_k$ for some finite natural number $k$.
In general, the number of variables grows with the order of the group.
\begin{itemize}
\item
  There is a first-order formula that has $O(1)$ variables, but $O(\log n)$ quantifier alternations, using the strategy from the $\PSPACE$-completeness of $\textsc{TQBF}$ \autocite[Lemma~2.3]{nt16}.
  This places the problem in $\FO[\log n]$, which is $\AC^1$, but doesn't provide placement in any finite level of the $\para \WNC$ hierarchy.
\item
  The authors of \autocite{bklm01} were not able to show membership in $\FO[\log \log n]$, which would have slightly improved the above membership, but still wouldn't place the problem in a finite level of the $\para \WNC$ hierarchy.
\item
  There is a first-order formula that has two alternations (beginning with $\forall$), but $O(\log n)$ variables \autocite[Lemma~3.5]{nt16}.
  The fact that the number of variables grows with the size of the input means this does not place the problem in any descriptive complexity class, nor any parameterized complexity class.
\item
  There is a $\FO[\DTC]$ formula for the problem, since group membership is in $\L$, which equals $\FO[\DTC]$.
  Although this subsumes the membership in $\FO[\log n]$ given in the first item above, this does not help us place the problem in a parameterized complexity class.
\end{itemize}
This basically means that the problem is in a class like $\para \WNC^2[\log n]$, and any improvement would likely follow an improvement of the desrciptive complexity of the subgroup membership problem.

\subsection{Completeness in \texorpdfstring{$\para \WNC[t]$}{paraWNC[t]}}

\todo{If we show a complete problem here, make sure to give a corollary in the section below that it is not in $\para \NC$ unless something bad happens.}

\subsection{Does \texorpdfstring{\para \NC}{paraNC} equal \texorpdfstring{\para \WNC[t]}{paraWNC[t]}?}

\begin{theorem}\label{thm:picsatgc}
  Suppose $d$ is a positive integer, $t$ is a positive integer greater than one, and $i$ is a circuit-computable nondecreasing function.
  $\PiCSAT$ is complete for $\GC[i(n) \log n, \Pi_t]$ under $\NC^d$ many-one reductions.
\end{theorem}
\begin{proof}
  \todo{Fill me in...}
\end{proof}

\begin{theorem}\label{thm:ppifsat}
  Suppose $d$ is a positive integer and $t$ is a positive integer greater than one.
  $\pPiFSAT$ is complete for $\para \WNC^d[t]$ under $\para \NC^d$ many-one reductions.
\end{theorem}
\begin{proof}
  \todo{Fill me in...}
\end{proof}

Since we will construct reductions between these problems, we need an efficient and highly parallel algorithm for transforming a circuit into an equivalent formula.
The input variables must be identical in order to guarantee that the parameter values are identical.

\begin{lemma}\label{lem:circuittoformula}
  Suppose $t$ is a positive integer.
  There is an $\NC^2$ many-one reduction from $\PiCSAT$ to $\PiFSAT$.
  Furthermore, the reduction preserves witnesses in the following (strong) sense.
  For each circuit $C$, if $\phi$ is the image of $C$ under the reduction, then $\Var(C) = \Var(\phi)$ and for each input vector $x$, we have $C(x) = 1$ if and only if $\phi(x) = 1$.
\end{lemma}
\begin{proof}
  The reduction operates as follows on input $(C, k)$, where $C$ is a Boolean circuit of size $m$ and depth $t$ and $k$ is a positive integer.
  Construct a trie (also known as a prefix tree) from the $O(m^t)$ possible paths from output gate to input gate, then output $(\phi, k)$, where $\phi$ is the Boolean formula represented by the constructed trie.
  The output gate is the root of the trie, the internal gates are the internal nodes of the tree, and the input gates are the leaf nodes of the trie (one leaf node for each input gate).
  By construction, the formula has the same set of variables as the circuit, and any path from output gate to input gate in the circuit has the same labels as the corresponding path in the trie, so for any input $x$, we have $C(x) = \phi(x)$.
  This also implies that $C$ has a satisfying assignment of weight $k$ if and only if $\phi$ has a satisfying assignment of weight $k$.

  Constructing a trie from $O(m^t)$ binary strings can be done by a circuit with $O(\log m^t)$ time and $O(m^{2t})$ size \autocite{lv86} (\todo{someone needs to verify this}).
  Since each ``character'' in our ``strings'' is really an element of $\{1, \dotsc, m\}$, there is an extra $O(\log m)$ depth penalty for reducing an alphabet of size $m$ to the binary alphabet.
  Thus the overall depth is $O(t \log^2 m)$ and the size $O(m^{2t} \log m)$.
  Since $t$ is a constant with respect to the size of the input $C$, this is an $\NC^2$ circuit.
\end{proof}

The following theorem is an adaptation of \autocite[Theorem~4.3]{cc97npo}.
It is a translation of \autoref{thm:ncwnc} to the finite levels of the $\WP$ hierarchy:
\begin{itemize}
\item the collapse $\para \NC^d = \para \WNC^d[t]$ is weaker than $\para \NC^d = \para \WNC^d$,
\item the inclusion $\GC[i(n) \log n, \Pi_t \LOGTIME] \subseteq \NC^d$ is weaker than the collapse $\NC^d = \NNC^d[i(n) \log n]$.
\end{itemize}
$\Pi_t \LOGTIME$ is a subclass of $\LH$, the logarithmic time hierarchy, which equals $\AC^0$ \autocite[Corollary~5.32]{immerman99}.
Since $\AC^0$ is a strict subset of $\NC^1$ \autocite{fss84}, $\Pi_t \LOGTIME$ is a strict subclass of $\NC^1$.
Although, $\Pi_t \LOGTIME$ is strictly weaker than $\NC^1$, the addition of $\omega(\log n)$ nondeterministic bits seems to give it power beyond that of $\NC$, which seems able to simulate only $O(\log n)$ bits (by enumerating each string of that length in parallel).
This theorem suggests that a collapse of the parameterized complexity classes yields a deterministic simulation of $\omega(\log n)$ bits, which would violate our intuition of nondeterminism.
See similar comments after \autocite[Theorem~4.3]{cc97npo} and compare with the conclusion of \autoref{con:wncp}.

\begin{theorem}\label{thm:ncwnct}
  Suppose $d$ and $t$ are positive integers with $t$ greater than one.
  $\para \NC^d = \para \WNC^d[t]$ if and only if there is a circuit-computable, unbounded, nondecreasing function $i$ such that %% $i(n) \leq n$ and
  $\GC[i(n) \log n, \Pi_t \LOGTIME] \subseteq \NC^d$.
\end{theorem}
\begin{proof}
  First, we prove the reverse implication.
  Assume there is a function $i$ such that $\GC[i(n) \log n, \Pi_t \LOGTIME] \subseteq \NC^d$.
  Since $\PiCSAT$ is in the class $\GC[i(n) \log n, \Pi_t \LOGTIME]$ by \autoref{thm:picsatgc}, it is now in $\NC^d$ as well.

  Since $\pPiFSAT$ is complete for $\para \WNC^d[t]$ under $\para \NC^d$ many-one reductions by \autoref{thm:ppifsat}, it suffices to show that $\pPiFSAT$ is in $\para \NC^d$.
  Furthermore, by \autoref{lem:spreduction}, it suffices to show that there is a small parameter $\NC^d$ many-one reduction from $\pPiFSAT$ to $\PiCSAT$.

  Let $\{R_n\}$ be the family of circuits computing the function $\phi \mapsto C_\phi$, where $\phi$ is a $\Pi_t$-normalized Boolean formula and $C_\phi$ is the natural $\Pi_t$ Boolean circuit induced by that formula.
  If we can show that $R_n$ is in $\NC^d$, then the parameter upper bound $i$ and $\{R_n\}$ together comprise a small parameter $\NC^d$ many-one reduction from $\pPiFSAT$ to $\PiCSAT$.

  Transforming a formula to its equivalent circuit is certainly computable in logarithmic space, so it is certainly in $\NC^2$.
  However, we can transform a Boolean formula into an equivalent Polish notation (prefix) Boolean formula in alternating logarithmic time \autocite{buss87}, which is in $\NC^1$, and from there we can write the adjacency matrix of the tree given by the prefix Boolean formula with an $\NC^1$ algorithm.

  Now we prove the forward implication.
  Assume $\para \NC^d = \para \WNC^d[t]$.
  Since $\pPiFSAT$ is in $\para \WNC^d[t]$ by \autoref{thm:ppifsat}, it is now in $\para \NC^d$ as well.
  We will use \autoref{lem:reducetonc} to show a reduction meeting the criteria of that lemma from $\PiCSAT$, which is complete for the class $\GC[i(n) \log n, \Pi_t \LOGTIME]$ under $\NC^d$ reductions by \autoref{thm:picsatgc}, to $\pPiFSAT$.
  \todo{Move that lemma down here, since it's only used here now?}

  Let $\{C_{m, k'}\}$ be the deterministic circuit family deciding $\pPiFSAT$ and $f$ the circuit-computable function such that
  \begin{itemize}
  \item for each $\phi$, we have $\phi$ is satisfiable if and only $C_{m, k'}(\phi) = 1$
  \item $\size(C_{m, k'}) \leq f(k') m^{O(1)}$,
  \item $\depth(C_{m, k'}) \leq f(k') + O(\log^d m)$.
  \end{itemize}
  Assume without loss of generality that $f$ is increasing.
  Choose $i$ to be the ``lower inverse'' function $i_{f, d}$ guaranteed by \autoref{lem:lowerinverse}.

  For the chosen function $i$, consider the problem $\PiCSAT$.
  By \autoref{lem:circuittoformula}, there is an $\NC^d$ reduction, $\{R_n\}$, from $\PiCSAT$ to $\PiFSAT$, the decision problem underlying the parameterized problem $\pPiFSAT$.
  Furthermore, since the variables and the satisfying assignments are identical, we have
  \begin{align*}
    f(\kappa'(R_n(C, k))) & = f(\kappa'(\phi, k)) \\
    & \leq f(k) \\
    & \leq f(i(n)) \\
    & \leq f(i_{f, d}(n)) \\
    & \leq \min(n, \log^d n).
  \end{align*}
  Thus the many-one reduction from \autoref{lem:circuittoformula} and the $\para \NC^d$ algorithm for $\pPiFSAT$ meet the conditions in the premise of \autoref{lem:reducetonc}.
  We conclude that $\PiCSAT$ is in $\NC^d$.
\end{proof}

\subsection{Is \texorpdfstring{$\para \WNC[t]$}{paraWNC[t]} in \texorpdfstring{$\para \P$}{paraP}?}

\todo{Translate everything from \autoref{sec:wncp}.}

\subsection{Does \texorpdfstring{$\para \WNC[t]$}{paraWNC[t]} equal \texorpdfstring{$\para \WP[t]$}{paraWP[t]}?}

\todo{Translate everything from \autoref{sec:wncwp}.}

%% Print the bibliography section here.
\printbibliography

\end{document}
